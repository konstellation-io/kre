// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/konstellation-io/kre/engine/admin-api/domain/entity"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	APIToken() ApiTokenResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Runtime() RuntimeResolver
	Subscription() SubscriptionResolver
	UserActivity() UserActivityResolver
	Version() VersionResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	ApiToken struct {
		CreationDate func(childComplexity int) int
		ID           func(childComplexity int) int
		LastActivity func(childComplexity int) int
		Name         func(childComplexity int) int
	}

	ConfigurationVariable struct {
		Key   func(childComplexity int) int
		Type  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	LogPage struct {
		Cursor func(childComplexity int) int
		Items  func(childComplexity int) int
	}

	MetricChartData struct {
		X func(childComplexity int) int
		Y func(childComplexity int) int
		Z func(childComplexity int) int
	}

	Metrics struct {
		Charts func(childComplexity int) int
		Values func(childComplexity int) int
	}

	MetricsAccuracy struct {
		Macro    func(childComplexity int) int
		Micro    func(childComplexity int) int
		Total    func(childComplexity int) int
		Weighted func(childComplexity int) int
	}

	MetricsCharts struct {
		ConfusionMatrix func(childComplexity int) int
		SeriesAccuracy  func(childComplexity int) int
		SeriesRecall    func(childComplexity int) int
		SeriesSupport   func(childComplexity int) int
		SuccessVsFails  func(childComplexity int) int
	}

	MetricsValues struct {
		Accuracy  func(childComplexity int) int
		Missing   func(childComplexity int) int
		NewLabels func(childComplexity int) int
	}

	Mutation struct {
		CreateRuntime                  func(childComplexity int, input CreateRuntimeInput) int
		CreateVersion                  func(childComplexity int, input CreateVersionInput) int
		PublishVersion                 func(childComplexity int, input PublishVersionInput) int
		StartVersion                   func(childComplexity int, input StartVersionInput) int
		StopVersion                    func(childComplexity int, input StopVersionInput) int
		UnpublishVersion               func(childComplexity int, input UnpublishVersionInput) int
		UpdateAccessLevel              func(childComplexity int, input UpdateAccessLevelInput) int
		UpdateVersionUserConfiguration func(childComplexity int, input UpdateConfigurationInput) int
	}

	Node struct {
		ID            func(childComplexity int) int
		Name          func(childComplexity int) int
		Replicas      func(childComplexity int) int
		Status        func(childComplexity int) int
		Subscriptions func(childComplexity int) int
	}

	NodeLog struct {
		Date         func(childComplexity int) int
		ID           func(childComplexity int) int
		Level        func(childComplexity int) int
		Message      func(childComplexity int) int
		NodeID       func(childComplexity int) int
		NodeName     func(childComplexity int) int
		WorkflowID   func(childComplexity int) int
		WorkflowName func(childComplexity int) int
	}

	Query struct {
		Logs             func(childComplexity int, runtimeID string, filters entity.LogFilters, cursor *string) int
		Metrics          func(childComplexity int, runtimeID string, versionName string, startDate string, endDate string) int
		Runtime          func(childComplexity int, id string) int
		Runtimes         func(childComplexity int) int
		UserActivityList func(childComplexity int, userEmail *string, types []entity.UserActivityType, versionIds []string, fromDate *string, toDate *string, lastID *string) int
		Version          func(childComplexity int, name string, runtimeID string) int
		Versions         func(childComplexity int, runtimeID string) int
	}

	Runtime struct {
		CreationAuthor    func(childComplexity int) int
		CreationDate      func(childComplexity int) int
		DatabaseURL       func(childComplexity int) int
		Description       func(childComplexity int) int
		EntrypointAddress func(childComplexity int) int
		ID                func(childComplexity int) int
		MeasurementsURL   func(childComplexity int) int
		Name              func(childComplexity int) int
		PublishedVersion  func(childComplexity int) int
	}

	Settings struct {
		AuthAllowedDomains    func(childComplexity int) int
		SessionLifetimeInDays func(childComplexity int) int
	}

	Subscription struct {
		WatchNodeLogs   func(childComplexity int, runtimeID string, versionName string, filters entity.LogFilters) int
		WatchNodeStatus func(childComplexity int, versionName string, runtimeID string) int
		WatchVersion    func(childComplexity int) int
	}

	UserActivity struct {
		Date func(childComplexity int) int
		ID   func(childComplexity int) int
		Type func(childComplexity int) int
		User func(childComplexity int) int
		Vars func(childComplexity int) int
	}

	UserActivityVar struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Version struct {
		Config            func(childComplexity int) int
		CreationAuthor    func(childComplexity int) int
		CreationDate      func(childComplexity int) int
		Description       func(childComplexity int) int
		Errors            func(childComplexity int) int
		HasDoc            func(childComplexity int) int
		ID                func(childComplexity int) int
		KrtVersion        func(childComplexity int) int
		Name              func(childComplexity int) int
		PublicationAuthor func(childComplexity int) int
		PublicationDate   func(childComplexity int) int
		Status            func(childComplexity int) int
		Workflows         func(childComplexity int) int
	}

	VersionUserConfig struct {
		Completed func(childComplexity int) int
		Vars      func(childComplexity int) int
	}

	Workflow struct {
		Entrypoint func(childComplexity int) int
		Exitpoint  func(childComplexity int) int
		ID         func(childComplexity int) int
		Name       func(childComplexity int) int
		Nodes      func(childComplexity int) int
	}
}

type ApiTokenResolver interface {
	CreationDate(ctx context.Context, obj *entity.APIToken) (string, error)
	LastActivity(ctx context.Context, obj *entity.APIToken) (*string, error)
}
type MutationResolver interface {
	CreateRuntime(ctx context.Context, input CreateRuntimeInput) (*entity.Runtime, error)
	CreateVersion(ctx context.Context, input CreateVersionInput) (*entity.Version, error)
	StartVersion(ctx context.Context, input StartVersionInput) (*entity.Version, error)
	StopVersion(ctx context.Context, input StopVersionInput) (*entity.Version, error)
	PublishVersion(ctx context.Context, input PublishVersionInput) (*entity.Version, error)
	UnpublishVersion(ctx context.Context, input UnpublishVersionInput) (*entity.Version, error)
	UpdateVersionUserConfiguration(ctx context.Context, input UpdateConfigurationInput) (*entity.Version, error)
	UpdateAccessLevel(ctx context.Context, input UpdateAccessLevelInput) ([]string, error)
}
type QueryResolver interface {
	Runtime(ctx context.Context, id string) (*entity.Runtime, error)
	Runtimes(ctx context.Context) ([]*entity.Runtime, error)
	Version(ctx context.Context, name string, runtimeID string) (*entity.Version, error)
	Versions(ctx context.Context, runtimeID string) ([]*entity.Version, error)
	UserActivityList(ctx context.Context, userEmail *string, types []entity.UserActivityType, versionIds []string, fromDate *string, toDate *string, lastID *string) ([]*entity.UserActivity, error)
	Logs(ctx context.Context, runtimeID string, filters entity.LogFilters, cursor *string) (*LogPage, error)
	Metrics(ctx context.Context, runtimeID string, versionName string, startDate string, endDate string) (*entity.Metrics, error)
}
type RuntimeResolver interface {
	CreationDate(ctx context.Context, obj *entity.Runtime) (string, error)
	MeasurementsURL(ctx context.Context, obj *entity.Runtime) (string, error)
	DatabaseURL(ctx context.Context, obj *entity.Runtime) (string, error)
	EntrypointAddress(ctx context.Context, obj *entity.Runtime) (string, error)
	PublishedVersion(ctx context.Context, obj *entity.Runtime) (*entity.Version, error)
	CreationAuthor(ctx context.Context, obj *entity.Runtime) (string, error)
}
type SubscriptionResolver interface {
	WatchNodeLogs(ctx context.Context, runtimeID string, versionName string, filters entity.LogFilters) (<-chan *entity.NodeLog, error)
	WatchNodeStatus(ctx context.Context, versionName string, runtimeID string) (<-chan *entity.Node, error)
	WatchVersion(ctx context.Context) (<-chan *entity.Version, error)
}
type UserActivityResolver interface {
	User(ctx context.Context, obj *entity.UserActivity) (string, error)
	Date(ctx context.Context, obj *entity.UserActivity) (string, error)
}
type VersionResolver interface {
	CreationDate(ctx context.Context, obj *entity.Version) (string, error)
	CreationAuthor(ctx context.Context, obj *entity.Version) (string, error)
	PublicationDate(ctx context.Context, obj *entity.Version) (*string, error)
	PublicationAuthor(ctx context.Context, obj *entity.Version) (*string, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec

	switch typeName + "." + field {
	case "ApiToken.creationDate":
		if e.complexity.ApiToken.CreationDate == nil {
			break
		}

		return e.complexity.ApiToken.CreationDate(childComplexity), true

	case "ApiToken.id":
		if e.complexity.ApiToken.ID == nil {
			break
		}

		return e.complexity.ApiToken.ID(childComplexity), true

	case "ApiToken.lastActivity":
		if e.complexity.ApiToken.LastActivity == nil {
			break
		}

		return e.complexity.ApiToken.LastActivity(childComplexity), true

	case "ApiToken.name":
		if e.complexity.ApiToken.Name == nil {
			break
		}

		return e.complexity.ApiToken.Name(childComplexity), true

	case "ConfigurationVariable.key":
		if e.complexity.ConfigurationVariable.Key == nil {
			break
		}

		return e.complexity.ConfigurationVariable.Key(childComplexity), true

	case "ConfigurationVariable.type":
		if e.complexity.ConfigurationVariable.Type == nil {
			break
		}

		return e.complexity.ConfigurationVariable.Type(childComplexity), true

	case "ConfigurationVariable.value":
		if e.complexity.ConfigurationVariable.Value == nil {
			break
		}

		return e.complexity.ConfigurationVariable.Value(childComplexity), true

	case "LogPage.cursor":
		if e.complexity.LogPage.Cursor == nil {
			break
		}

		return e.complexity.LogPage.Cursor(childComplexity), true

	case "LogPage.items":
		if e.complexity.LogPage.Items == nil {
			break
		}

		return e.complexity.LogPage.Items(childComplexity), true

	case "MetricChartData.x":
		if e.complexity.MetricChartData.X == nil {
			break
		}

		return e.complexity.MetricChartData.X(childComplexity), true

	case "MetricChartData.y":
		if e.complexity.MetricChartData.Y == nil {
			break
		}

		return e.complexity.MetricChartData.Y(childComplexity), true

	case "MetricChartData.z":
		if e.complexity.MetricChartData.Z == nil {
			break
		}

		return e.complexity.MetricChartData.Z(childComplexity), true

	case "Metrics.charts":
		if e.complexity.Metrics.Charts == nil {
			break
		}

		return e.complexity.Metrics.Charts(childComplexity), true

	case "Metrics.values":
		if e.complexity.Metrics.Values == nil {
			break
		}

		return e.complexity.Metrics.Values(childComplexity), true

	case "MetricsAccuracy.macro":
		if e.complexity.MetricsAccuracy.Macro == nil {
			break
		}

		return e.complexity.MetricsAccuracy.Macro(childComplexity), true

	case "MetricsAccuracy.micro":
		if e.complexity.MetricsAccuracy.Micro == nil {
			break
		}

		return e.complexity.MetricsAccuracy.Micro(childComplexity), true

	case "MetricsAccuracy.total":
		if e.complexity.MetricsAccuracy.Total == nil {
			break
		}

		return e.complexity.MetricsAccuracy.Total(childComplexity), true

	case "MetricsAccuracy.weighted":
		if e.complexity.MetricsAccuracy.Weighted == nil {
			break
		}

		return e.complexity.MetricsAccuracy.Weighted(childComplexity), true

	case "MetricsCharts.confusionMatrix":
		if e.complexity.MetricsCharts.ConfusionMatrix == nil {
			break
		}

		return e.complexity.MetricsCharts.ConfusionMatrix(childComplexity), true

	case "MetricsCharts.seriesAccuracy":
		if e.complexity.MetricsCharts.SeriesAccuracy == nil {
			break
		}

		return e.complexity.MetricsCharts.SeriesAccuracy(childComplexity), true

	case "MetricsCharts.seriesRecall":
		if e.complexity.MetricsCharts.SeriesRecall == nil {
			break
		}

		return e.complexity.MetricsCharts.SeriesRecall(childComplexity), true

	case "MetricsCharts.seriesSupport":
		if e.complexity.MetricsCharts.SeriesSupport == nil {
			break
		}

		return e.complexity.MetricsCharts.SeriesSupport(childComplexity), true

	case "MetricsCharts.successVsFails":
		if e.complexity.MetricsCharts.SuccessVsFails == nil {
			break
		}

		return e.complexity.MetricsCharts.SuccessVsFails(childComplexity), true

	case "MetricsValues.accuracy":
		if e.complexity.MetricsValues.Accuracy == nil {
			break
		}

		return e.complexity.MetricsValues.Accuracy(childComplexity), true

	case "MetricsValues.missing":
		if e.complexity.MetricsValues.Missing == nil {
			break
		}

		return e.complexity.MetricsValues.Missing(childComplexity), true

	case "MetricsValues.newLabels":
		if e.complexity.MetricsValues.NewLabels == nil {
			break
		}

		return e.complexity.MetricsValues.NewLabels(childComplexity), true

	case "Mutation.createRuntime":
		if e.complexity.Mutation.CreateRuntime == nil {
			break
		}

		args, err := ec.field_Mutation_createRuntime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRuntime(childComplexity, args["input"].(CreateRuntimeInput)), true

	case "Mutation.createVersion":
		if e.complexity.Mutation.CreateVersion == nil {
			break
		}

		args, err := ec.field_Mutation_createVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateVersion(childComplexity, args["input"].(CreateVersionInput)), true

	case "Mutation.publishVersion":
		if e.complexity.Mutation.PublishVersion == nil {
			break
		}

		args, err := ec.field_Mutation_publishVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PublishVersion(childComplexity, args["input"].(PublishVersionInput)), true

	case "Mutation.startVersion":
		if e.complexity.Mutation.StartVersion == nil {
			break
		}

		args, err := ec.field_Mutation_startVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.StartVersion(childComplexity, args["input"].(StartVersionInput)), true

	case "Mutation.stopVersion":
		if e.complexity.Mutation.StopVersion == nil {
			break
		}

		args, err := ec.field_Mutation_stopVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.StopVersion(childComplexity, args["input"].(StopVersionInput)), true

	case "Mutation.unpublishVersion":
		if e.complexity.Mutation.UnpublishVersion == nil {
			break
		}

		args, err := ec.field_Mutation_unpublishVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnpublishVersion(childComplexity, args["input"].(UnpublishVersionInput)), true

	case "Mutation.updateAccessLevel":
		if e.complexity.Mutation.UpdateAccessLevel == nil {
			break
		}

		args, err := ec.field_Mutation_updateAccessLevel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAccessLevel(childComplexity, args["input"].(UpdateAccessLevelInput)), true

	case "Mutation.updateVersionUserConfiguration":
		if e.complexity.Mutation.UpdateVersionUserConfiguration == nil {
			break
		}

		args, err := ec.field_Mutation_updateVersionUserConfiguration_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateVersionUserConfiguration(childComplexity, args["input"].(UpdateConfigurationInput)), true

	case "Node.id":
		if e.complexity.Node.ID == nil {
			break
		}

		return e.complexity.Node.ID(childComplexity), true

	case "Node.name":
		if e.complexity.Node.Name == nil {
			break
		}

		return e.complexity.Node.Name(childComplexity), true

	case "Node.replicas":
		if e.complexity.Node.Replicas == nil {
			break
		}

		return e.complexity.Node.Replicas(childComplexity), true

	case "Node.status":
		if e.complexity.Node.Status == nil {
			break
		}

		return e.complexity.Node.Status(childComplexity), true

	case "Node.subscriptions":
		if e.complexity.Node.Subscriptions == nil {
			break
		}

		return e.complexity.Node.Subscriptions(childComplexity), true

	case "NodeLog.date":
		if e.complexity.NodeLog.Date == nil {
			break
		}

		return e.complexity.NodeLog.Date(childComplexity), true

	case "NodeLog.id":
		if e.complexity.NodeLog.ID == nil {
			break
		}

		return e.complexity.NodeLog.ID(childComplexity), true

	case "NodeLog.level":
		if e.complexity.NodeLog.Level == nil {
			break
		}

		return e.complexity.NodeLog.Level(childComplexity), true

	case "NodeLog.message":
		if e.complexity.NodeLog.Message == nil {
			break
		}

		return e.complexity.NodeLog.Message(childComplexity), true

	case "NodeLog.nodeId":
		if e.complexity.NodeLog.NodeID == nil {
			break
		}

		return e.complexity.NodeLog.NodeID(childComplexity), true

	case "NodeLog.nodeName":
		if e.complexity.NodeLog.NodeName == nil {
			break
		}

		return e.complexity.NodeLog.NodeName(childComplexity), true

	case "NodeLog.workflowId":
		if e.complexity.NodeLog.WorkflowID == nil {
			break
		}

		return e.complexity.NodeLog.WorkflowID(childComplexity), true

	case "NodeLog.workflowName":
		if e.complexity.NodeLog.WorkflowName == nil {
			break
		}

		return e.complexity.NodeLog.WorkflowName(childComplexity), true

	case "Query.logs":
		if e.complexity.Query.Logs == nil {
			break
		}

		args, err := ec.field_Query_logs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Logs(childComplexity, args["runtimeId"].(string), args["filters"].(entity.LogFilters), args["cursor"].(*string)), true

	case "Query.metrics":
		if e.complexity.Query.Metrics == nil {
			break
		}

		args, err := ec.field_Query_metrics_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Metrics(childComplexity, args["runtimeId"].(string), args["versionName"].(string), args["startDate"].(string), args["endDate"].(string)), true

	case "Query.runtime":
		if e.complexity.Query.Runtime == nil {
			break
		}

		args, err := ec.field_Query_runtime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Runtime(childComplexity, args["id"].(string)), true

	case "Query.runtimes":
		if e.complexity.Query.Runtimes == nil {
			break
		}

		return e.complexity.Query.Runtimes(childComplexity), true

	case "Query.userActivityList":
		if e.complexity.Query.UserActivityList == nil {
			break
		}

		args, err := ec.field_Query_userActivityList_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserActivityList(childComplexity, args["userEmail"].(*string), args["types"].([]entity.UserActivityType), args["versionIds"].([]string), args["fromDate"].(*string), args["toDate"].(*string), args["lastId"].(*string)), true

	case "Query.version":
		if e.complexity.Query.Version == nil {
			break
		}

		args, err := ec.field_Query_version_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Version(childComplexity, args["name"].(string), args["runtimeId"].(string)), true

	case "Query.versions":
		if e.complexity.Query.Versions == nil {
			break
		}

		args, err := ec.field_Query_versions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Versions(childComplexity, args["runtimeId"].(string)), true

	case "Runtime.creationAuthor":
		if e.complexity.Runtime.CreationAuthor == nil {
			break
		}

		return e.complexity.Runtime.CreationAuthor(childComplexity), true

	case "Runtime.creationDate":
		if e.complexity.Runtime.CreationDate == nil {
			break
		}

		return e.complexity.Runtime.CreationDate(childComplexity), true

	case "Runtime.databaseUrl":
		if e.complexity.Runtime.DatabaseURL == nil {
			break
		}

		return e.complexity.Runtime.DatabaseURL(childComplexity), true

	case "Runtime.description":
		if e.complexity.Runtime.Description == nil {
			break
		}

		return e.complexity.Runtime.Description(childComplexity), true

	case "Runtime.entrypointAddress":
		if e.complexity.Runtime.EntrypointAddress == nil {
			break
		}

		return e.complexity.Runtime.EntrypointAddress(childComplexity), true

	case "Runtime.id":
		if e.complexity.Runtime.ID == nil {
			break
		}

		return e.complexity.Runtime.ID(childComplexity), true

	case "Runtime.measurementsUrl":
		if e.complexity.Runtime.MeasurementsURL == nil {
			break
		}

		return e.complexity.Runtime.MeasurementsURL(childComplexity), true

	case "Runtime.name":
		if e.complexity.Runtime.Name == nil {
			break
		}

		return e.complexity.Runtime.Name(childComplexity), true

	case "Runtime.publishedVersion":
		if e.complexity.Runtime.PublishedVersion == nil {
			break
		}

		return e.complexity.Runtime.PublishedVersion(childComplexity), true

	case "Settings.authAllowedDomains":
		if e.complexity.Settings.AuthAllowedDomains == nil {
			break
		}

		return e.complexity.Settings.AuthAllowedDomains(childComplexity), true

	case "Settings.sessionLifetimeInDays":
		if e.complexity.Settings.SessionLifetimeInDays == nil {
			break
		}

		return e.complexity.Settings.SessionLifetimeInDays(childComplexity), true

	case "Subscription.watchNodeLogs":
		if e.complexity.Subscription.WatchNodeLogs == nil {
			break
		}

		args, err := ec.field_Subscription_watchNodeLogs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.WatchNodeLogs(childComplexity, args["runtimeId"].(string), args["versionName"].(string), args["filters"].(entity.LogFilters)), true

	case "Subscription.watchNodeStatus":
		if e.complexity.Subscription.WatchNodeStatus == nil {
			break
		}

		args, err := ec.field_Subscription_watchNodeStatus_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.WatchNodeStatus(childComplexity, args["versionName"].(string), args["runtimeId"].(string)), true

	case "Subscription.watchVersion":
		if e.complexity.Subscription.WatchVersion == nil {
			break
		}

		return e.complexity.Subscription.WatchVersion(childComplexity), true

	case "UserActivity.date":
		if e.complexity.UserActivity.Date == nil {
			break
		}

		return e.complexity.UserActivity.Date(childComplexity), true

	case "UserActivity.id":
		if e.complexity.UserActivity.ID == nil {
			break
		}

		return e.complexity.UserActivity.ID(childComplexity), true

	case "UserActivity.type":
		if e.complexity.UserActivity.Type == nil {
			break
		}

		return e.complexity.UserActivity.Type(childComplexity), true

	case "UserActivity.user":
		if e.complexity.UserActivity.User == nil {
			break
		}

		return e.complexity.UserActivity.User(childComplexity), true

	case "UserActivity.vars":
		if e.complexity.UserActivity.Vars == nil {
			break
		}

		return e.complexity.UserActivity.Vars(childComplexity), true

	case "UserActivityVar.key":
		if e.complexity.UserActivityVar.Key == nil {
			break
		}

		return e.complexity.UserActivityVar.Key(childComplexity), true

	case "UserActivityVar.value":
		if e.complexity.UserActivityVar.Value == nil {
			break
		}

		return e.complexity.UserActivityVar.Value(childComplexity), true

	case "Version.config":
		if e.complexity.Version.Config == nil {
			break
		}

		return e.complexity.Version.Config(childComplexity), true

	case "Version.creationAuthor":
		if e.complexity.Version.CreationAuthor == nil {
			break
		}

		return e.complexity.Version.CreationAuthor(childComplexity), true

	case "Version.creationDate":
		if e.complexity.Version.CreationDate == nil {
			break
		}

		return e.complexity.Version.CreationDate(childComplexity), true

	case "Version.description":
		if e.complexity.Version.Description == nil {
			break
		}

		return e.complexity.Version.Description(childComplexity), true

	case "Version.errors":
		if e.complexity.Version.Errors == nil {
			break
		}

		return e.complexity.Version.Errors(childComplexity), true

	case "Version.hasDoc":
		if e.complexity.Version.HasDoc == nil {
			break
		}

		return e.complexity.Version.HasDoc(childComplexity), true

	case "Version.id":
		if e.complexity.Version.ID == nil {
			break
		}

		return e.complexity.Version.ID(childComplexity), true

	case "Version.krtVersion":
		if e.complexity.Version.KrtVersion == nil {
			break
		}

		return e.complexity.Version.KrtVersion(childComplexity), true

	case "Version.name":
		if e.complexity.Version.Name == nil {
			break
		}

		return e.complexity.Version.Name(childComplexity), true

	case "Version.publicationAuthor":
		if e.complexity.Version.PublicationAuthor == nil {
			break
		}

		return e.complexity.Version.PublicationAuthor(childComplexity), true

	case "Version.publicationDate":
		if e.complexity.Version.PublicationDate == nil {
			break
		}

		return e.complexity.Version.PublicationDate(childComplexity), true

	case "Version.status":
		if e.complexity.Version.Status == nil {
			break
		}

		return e.complexity.Version.Status(childComplexity), true

	case "Version.workflows":
		if e.complexity.Version.Workflows == nil {
			break
		}

		return e.complexity.Version.Workflows(childComplexity), true

	case "VersionUserConfig.completed":
		if e.complexity.VersionUserConfig.Completed == nil {
			break
		}

		return e.complexity.VersionUserConfig.Completed(childComplexity), true

	case "VersionUserConfig.vars":
		if e.complexity.VersionUserConfig.Vars == nil {
			break
		}

		return e.complexity.VersionUserConfig.Vars(childComplexity), true

	case "Workflow.entrypoint":
		if e.complexity.Workflow.Entrypoint == nil {
			break
		}

		return e.complexity.Workflow.Entrypoint(childComplexity), true

	case "Workflow.exitpoint":
		if e.complexity.Workflow.Exitpoint == nil {
			break
		}

		return e.complexity.Workflow.Exitpoint(childComplexity), true

	case "Workflow.id":
		if e.complexity.Workflow.ID == nil {
			break
		}

		return e.complexity.Workflow.ID(childComplexity), true

	case "Workflow.name":
		if e.complexity.Workflow.Name == nil {
			break
		}

		return e.complexity.Workflow.Name(childComplexity), true

	case "Workflow.nodes":
		if e.complexity.Workflow.Nodes == nil {
			break
		}

		return e.complexity.Workflow.Nodes(childComplexity), true
	}

	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputConfigurationVariablesInput,
		ec.unmarshalInputCreateRuntimeInput,
		ec.unmarshalInputCreateVersionInput,
		ec.unmarshalInputLogFilters,
		ec.unmarshalInputPublishVersionInput,
		ec.unmarshalInputSettingsInput,
		ec.unmarshalInputStartVersionInput,
		ec.unmarshalInputStopVersionInput,
		ec.unmarshalInputUnpublishVersionInput,
		ec.unmarshalInputUpdateAccessLevelInput,
		ec.unmarshalInputUpdateConfigurationInput,
		ec.unmarshalInputUsersInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}

			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)

			var buf bytes.Buffer

			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}

			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)

			var buf bytes.Buffer

			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer

		return func(ctx context.Context) *graphql.Response {
			buf.Reset()

			data := next(ctx)

			if data == nil {
				return nil
			}

			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}

	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}

	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../schema.graphql", Input: `scalar Upload

type Query {
  runtime(id: ID!): Runtime!
  runtimes: [Runtime!]!
  version(name: String!, runtimeId: ID!): Version!
  versions(runtimeId: ID!): [Version!]!
  userActivityList(
    userEmail: String
    types: [UserActivityType!]
    versionIds: [String!]
    fromDate: String
    toDate: String
    lastId: String
  ): [UserActivity!]!
  logs(runtimeId: ID!, filters: LogFilters!, cursor: String): LogPage!
  metrics(
    runtimeId: ID!
    versionName: String!
    startDate: String!
    endDate: String!
  ): Metrics
}

type Mutation {
  createRuntime(input: CreateRuntimeInput!): Runtime!
  createVersion(input: CreateVersionInput!): Version!
  startVersion(input: StartVersionInput!): Version!
  stopVersion(input: StopVersionInput!): Version!
  publishVersion(input: PublishVersionInput!): Version!
  unpublishVersion(input: UnpublishVersionInput!): Version!
  updateVersionUserConfiguration(input: UpdateConfigurationInput!): Version!
  updateAccessLevel(input: UpdateAccessLevelInput!): [String!]! # TODO: refactor
}

type Subscription {
  watchNodeLogs(
    runtimeId: ID!
    versionName: String!
    filters: LogFilters!
  ): NodeLog!
  watchNodeStatus(versionName: String!, runtimeId: ID!): Node!
  watchVersion: Version!
}

input CreateRuntimeInput {
  id: String!
  name: String!
  description: String!
}

input CreateVersionInput {
  file: Upload!
  runtimeId: ID!
}

input StartVersionInput {
  versionName: String!
  comment: String!
  runtimeId: ID!
}

input StopVersionInput {
  versionName: String!
  comment: String!
  runtimeId: ID!
}

input PublishVersionInput {
  versionName: String!
  comment: String!
  runtimeId: ID!
}

input UnpublishVersionInput {
  versionName: String!
  comment: String!
  runtimeId: ID!
}

input UsersInput {
  userIds: [ID!]!
  comment: String!
}

input UpdateAccessLevelInput {
  userIds: [ID!]!
  accessLevel: AccessLevel!
  comment: String!
}

input SettingsInput {
  authAllowedDomains: [String!]
  sessionLifetimeInDays: Int
}

enum AccessLevel {
  VIEWER
  MANAGER
  ADMIN
}

type ApiToken {
  id: ID!
  name: String!
  creationDate: String!
  lastActivity: String
}

type ConfigurationVariable {
  key: String!
  value: String!
  type: ConfigurationVariableType!
}

enum ConfigurationVariableType {
  VARIABLE
  FILE
}

input ConfigurationVariablesInput {
  key: String!
  value: String!
}

input UpdateConfigurationInput {
  versionName: String!
  runtimeId: ID!
  configurationVariables: [ConfigurationVariablesInput!]!
}

type Runtime {
  id: ID!
  name: String!
  description: String!
  creationDate: String!
  measurementsUrl: String!
  databaseUrl: String!
  entrypointAddress: String!
  publishedVersion: Version
  creationAuthor: String!
}

type Node {
  id: ID!
  name: String!
  status: NodeStatus!
  subscriptions: [String!]
  replicas: Int!
}

enum NodeStatus {
  STARTING
  STARTED
  STOPPED
  ERROR
}

type Workflow {
  id: ID!
  name: String!
  entrypoint: String
  exitpoint: String
  nodes: [Node!]!
}

enum KrtVersion {
  v2
}

type Version {
  id: ID!
  krtVersion: KrtVersion!
  name: String!
  description: String!
  status: VersionStatus!
  creationDate: String!
  creationAuthor: String!
  publicationDate: String
  publicationAuthor: String
  workflows: [Workflow!]!
  config: VersionUserConfig!
  hasDoc: Boolean
  errors: [String!]!
}

type VersionUserConfig {
  vars: [ConfigurationVariable!]!
  completed: Boolean!
}

enum VersionStatus {
  CREATING
  CREATED
  STARTING
  STARTED
  PUBLISHED
  STOPPING
  STOPPED
  ERROR
}

type Settings {
  authAllowedDomains: [String!]!
  sessionLifetimeInDays: Int!
}

type UserActivityVar {
  key: String!
  value: String!
}

type UserActivity {
  id: ID!
  type: UserActivityType!
  user: String!
  date: String!
  vars: [UserActivityVar!]!
}

enum UserActivityType {
  LOGIN
  LOGOUT
  CREATE_RUNTIME
  CREATE_VERSION
  PUBLISH_VERSION
  UNPUBLISH_VERSION
  START_VERSION
  STOP_VERSION
  UPDATE_SETTING
  UPDATE_VERSION_CONFIGURATION
  CREATE_USER
  REMOVE_USERS
  UPDATE_ACCESS_LEVELS
  REVOKE_SESSIONS
  GENERATE_API_TOKEN
  DELETE_API_TOKEN
}

input LogFilters {
  startDate: String!
  endDate: String
  search: String
  levels: [LogLevel!]
  nodeIds: [ID!]
  versionsIds: [ID!]
  workflowsNames: [ID!]
}

enum LogLevel {
  ERROR
  WARN
  INFO
  DEBUG
}

type NodeLog {
  id: ID!
  date: String!
  nodeId: String
  nodeName: String
  workflowId: String
  workflowName: String
  message: String!
  level: LogLevel!
}

type LogPage {
  cursor: String
  items: [NodeLog!]!
}

type Metrics {
  values: MetricsValues!
  charts: MetricsCharts!
}

type MetricsValues {
  accuracy: MetricsAccuracy!
  missing: Int!
  newLabels: Int!
}

type MetricsAccuracy {
  total: Int!
  micro: Int!
  macro: Int!
  weighted: Int!
}

type MetricsCharts {
  confusionMatrix: [MetricChartData!]!
  seriesAccuracy: [MetricChartData!]!
  seriesRecall: [MetricChartData!]!
  seriesSupport: [MetricChartData!]!
  successVsFails: [MetricChartData!]!
}

type MetricChartData {
  x: String!
  y: String!
  z: String!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_createRuntime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 CreateRuntimeInput

	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))

		arg0, err = ec.unmarshalNCreateRuntimeInput2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐCreateRuntimeInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["input"] = arg0

	return args, nil
}

func (ec *executionContext) field_Mutation_createVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 CreateVersionInput

	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))

		arg0, err = ec.unmarshalNCreateVersionInput2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐCreateVersionInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["input"] = arg0

	return args, nil
}

func (ec *executionContext) field_Mutation_publishVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 PublishVersionInput

	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))

		arg0, err = ec.unmarshalNPublishVersionInput2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐPublishVersionInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["input"] = arg0

	return args, nil
}

func (ec *executionContext) field_Mutation_startVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 StartVersionInput

	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))

		arg0, err = ec.unmarshalNStartVersionInput2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐStartVersionInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["input"] = arg0

	return args, nil
}

func (ec *executionContext) field_Mutation_stopVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 StopVersionInput

	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))

		arg0, err = ec.unmarshalNStopVersionInput2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐStopVersionInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["input"] = arg0

	return args, nil
}

func (ec *executionContext) field_Mutation_unpublishVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 UnpublishVersionInput

	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))

		arg0, err = ec.unmarshalNUnpublishVersionInput2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐUnpublishVersionInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["input"] = arg0

	return args, nil
}

func (ec *executionContext) field_Mutation_updateAccessLevel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 UpdateAccessLevelInput

	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))

		arg0, err = ec.unmarshalNUpdateAccessLevelInput2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐUpdateAccessLevelInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["input"] = arg0

	return args, nil
}

func (ec *executionContext) field_Mutation_updateVersionUserConfiguration_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 UpdateConfigurationInput

	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))

		arg0, err = ec.unmarshalNUpdateConfigurationInput2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐUpdateConfigurationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["input"] = arg0

	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 string

	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))

		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["name"] = arg0

	return args, nil
}

func (ec *executionContext) field_Query_logs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 string

	if tmp, ok := rawArgs["runtimeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeId"))

		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["runtimeId"] = arg0

	var arg1 entity.LogFilters

	if tmp, ok := rawArgs["filters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))

		arg1, err = ec.unmarshalNLogFilters2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐLogFilters(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["filters"] = arg1

	var arg2 *string

	if tmp, ok := rawArgs["cursor"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursor"))

		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["cursor"] = arg2

	return args, nil
}

func (ec *executionContext) field_Query_metrics_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 string

	if tmp, ok := rawArgs["runtimeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeId"))

		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["runtimeId"] = arg0

	var arg1 string

	if tmp, ok := rawArgs["versionName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionName"))

		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["versionName"] = arg1

	var arg2 string

	if tmp, ok := rawArgs["startDate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))

		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["startDate"] = arg2

	var arg3 string

	if tmp, ok := rawArgs["endDate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDate"))

		arg3, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["endDate"] = arg3

	return args, nil
}

func (ec *executionContext) field_Query_runtime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 string

	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))

		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["id"] = arg0

	return args, nil
}

func (ec *executionContext) field_Query_userActivityList_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 *string

	if tmp, ok := rawArgs["userEmail"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userEmail"))

		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["userEmail"] = arg0

	var arg1 []entity.UserActivityType

	if tmp, ok := rawArgs["types"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("types"))

		arg1, err = ec.unmarshalOUserActivityType2ᚕgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐUserActivityTypeᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["types"] = arg1

	var arg2 []string

	if tmp, ok := rawArgs["versionIds"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionIds"))

		arg2, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["versionIds"] = arg2

	var arg3 *string

	if tmp, ok := rawArgs["fromDate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fromDate"))

		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["fromDate"] = arg3

	var arg4 *string

	if tmp, ok := rawArgs["toDate"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toDate"))

		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["toDate"] = arg4

	var arg5 *string

	if tmp, ok := rawArgs["lastId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastId"))

		arg5, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["lastId"] = arg5

	return args, nil
}

func (ec *executionContext) field_Query_version_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 string

	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))

		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["name"] = arg0

	var arg1 string

	if tmp, ok := rawArgs["runtimeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeId"))

		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["runtimeId"] = arg1

	return args, nil
}

func (ec *executionContext) field_Query_versions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 string

	if tmp, ok := rawArgs["runtimeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeId"))

		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["runtimeId"] = arg0

	return args, nil
}

func (ec *executionContext) field_Subscription_watchNodeLogs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 string

	if tmp, ok := rawArgs["runtimeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeId"))

		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["runtimeId"] = arg0

	var arg1 string

	if tmp, ok := rawArgs["versionName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionName"))

		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["versionName"] = arg1

	var arg2 entity.LogFilters

	if tmp, ok := rawArgs["filters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))

		arg2, err = ec.unmarshalNLogFilters2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐLogFilters(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["filters"] = arg2

	return args, nil
}

func (ec *executionContext) field_Subscription_watchNodeStatus_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 string

	if tmp, ok := rawArgs["versionName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionName"))

		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["versionName"] = arg0

	var arg1 string

	if tmp, ok := rawArgs["runtimeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeId"))

		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["runtimeId"] = arg1

	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 bool

	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))

		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["includeDeprecated"] = arg0

	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error

	args := map[string]interface{}{}

	var arg0 bool

	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))

		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}

	args["includeDeprecated"] = arg0

	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ApiToken_id(ctx context.Context, field graphql.CollectedField, obj *entity.APIToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApiToken_id(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApiToken_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApiToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _ApiToken_name(ctx context.Context, field graphql.CollectedField, obj *entity.APIToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApiToken_name(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApiToken_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApiToken",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _ApiToken_creationDate(ctx context.Context, field graphql.CollectedField, obj *entity.APIToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApiToken_creationDate(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.APIToken().CreationDate(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApiToken_creationDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApiToken",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _ApiToken_lastActivity(ctx context.Context, field graphql.CollectedField, obj *entity.APIToken) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ApiToken_lastActivity(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.APIToken().LastActivity(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*string)
	fc.Result = res

	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ApiToken_lastActivity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ApiToken",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _ConfigurationVariable_key(ctx context.Context, field graphql.CollectedField, obj *entity.ConfigurationVariable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationVariable_key(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationVariable_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationVariable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _ConfigurationVariable_value(ctx context.Context, field graphql.CollectedField, obj *entity.ConfigurationVariable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationVariable_value(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationVariable_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationVariable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _ConfigurationVariable_type(ctx context.Context, field graphql.CollectedField, obj *entity.ConfigurationVariable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigurationVariable_type(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(entity.ConfigurationVariableType)
	fc.Result = res

	return ec.marshalNConfigurationVariableType2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐConfigurationVariableType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigurationVariable_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigurationVariable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConfigurationVariableType does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _LogPage_cursor(ctx context.Context, field graphql.CollectedField, obj *LogPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogPage_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*string)
	fc.Result = res

	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogPage_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _LogPage_items(ctx context.Context, field graphql.CollectedField, obj *LogPage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogPage_items(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]*entity.NodeLog)
	fc.Result = res

	return ec.marshalNNodeLog2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐNodeLogᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogPage_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogPage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_NodeLog_id(ctx, field)
			case "date":
				return ec.fieldContext_NodeLog_date(ctx, field)
			case "nodeId":
				return ec.fieldContext_NodeLog_nodeId(ctx, field)
			case "nodeName":
				return ec.fieldContext_NodeLog_nodeName(ctx, field)
			case "workflowId":
				return ec.fieldContext_NodeLog_workflowId(ctx, field)
			case "workflowName":
				return ec.fieldContext_NodeLog_workflowName(ctx, field)
			case "message":
				return ec.fieldContext_NodeLog_message(ctx, field)
			case "level":
				return ec.fieldContext_NodeLog_level(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeLog", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) _MetricChartData_x(ctx context.Context, field graphql.CollectedField, obj *entity.MetricChartData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetricChartData_x(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.X, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetricChartData_x(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetricChartData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _MetricChartData_y(ctx context.Context, field graphql.CollectedField, obj *entity.MetricChartData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetricChartData_y(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Y, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetricChartData_y(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetricChartData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _MetricChartData_z(ctx context.Context, field graphql.CollectedField, obj *entity.MetricChartData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetricChartData_z(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Z, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetricChartData_z(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetricChartData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Metrics_values(ctx context.Context, field graphql.CollectedField, obj *entity.Metrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Metrics_values(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Values, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(*entity.MetricsValues)
	fc.Result = res

	return ec.marshalNMetricsValues2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐMetricsValues(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Metrics_values(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Metrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "accuracy":
				return ec.fieldContext_MetricsValues_accuracy(ctx, field)
			case "missing":
				return ec.fieldContext_MetricsValues_missing(ctx, field)
			case "newLabels":
				return ec.fieldContext_MetricsValues_newLabels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MetricsValues", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) _Metrics_charts(ctx context.Context, field graphql.CollectedField, obj *entity.Metrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Metrics_charts(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Charts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(*entity.MetricsCharts)
	fc.Result = res

	return ec.marshalNMetricsCharts2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐMetricsCharts(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Metrics_charts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Metrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "confusionMatrix":
				return ec.fieldContext_MetricsCharts_confusionMatrix(ctx, field)
			case "seriesAccuracy":
				return ec.fieldContext_MetricsCharts_seriesAccuracy(ctx, field)
			case "seriesRecall":
				return ec.fieldContext_MetricsCharts_seriesRecall(ctx, field)
			case "seriesSupport":
				return ec.fieldContext_MetricsCharts_seriesSupport(ctx, field)
			case "successVsFails":
				return ec.fieldContext_MetricsCharts_successVsFails(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MetricsCharts", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) _MetricsAccuracy_total(ctx context.Context, field graphql.CollectedField, obj *entity.MetricsAccuracy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetricsAccuracy_total(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(int)
	fc.Result = res

	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetricsAccuracy_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetricsAccuracy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _MetricsAccuracy_micro(ctx context.Context, field graphql.CollectedField, obj *entity.MetricsAccuracy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetricsAccuracy_micro(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Micro, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(int)
	fc.Result = res

	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetricsAccuracy_micro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetricsAccuracy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _MetricsAccuracy_macro(ctx context.Context, field graphql.CollectedField, obj *entity.MetricsAccuracy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetricsAccuracy_macro(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Macro, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(int)
	fc.Result = res

	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetricsAccuracy_macro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetricsAccuracy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _MetricsAccuracy_weighted(ctx context.Context, field graphql.CollectedField, obj *entity.MetricsAccuracy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetricsAccuracy_weighted(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weighted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(int)
	fc.Result = res

	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetricsAccuracy_weighted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetricsAccuracy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _MetricsCharts_confusionMatrix(ctx context.Context, field graphql.CollectedField, obj *entity.MetricsCharts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetricsCharts_confusionMatrix(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfusionMatrix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]*entity.MetricChartData)
	fc.Result = res

	return ec.marshalNMetricChartData2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐMetricChartDataᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetricsCharts_confusionMatrix(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetricsCharts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_MetricChartData_x(ctx, field)
			case "y":
				return ec.fieldContext_MetricChartData_y(ctx, field)
			case "z":
				return ec.fieldContext_MetricChartData_z(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MetricChartData", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) _MetricsCharts_seriesAccuracy(ctx context.Context, field graphql.CollectedField, obj *entity.MetricsCharts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetricsCharts_seriesAccuracy(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SeriesAccuracy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]*entity.MetricChartData)
	fc.Result = res

	return ec.marshalNMetricChartData2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐMetricChartDataᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetricsCharts_seriesAccuracy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetricsCharts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_MetricChartData_x(ctx, field)
			case "y":
				return ec.fieldContext_MetricChartData_y(ctx, field)
			case "z":
				return ec.fieldContext_MetricChartData_z(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MetricChartData", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) _MetricsCharts_seriesRecall(ctx context.Context, field graphql.CollectedField, obj *entity.MetricsCharts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetricsCharts_seriesRecall(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SeriesRecall, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]*entity.MetricChartData)
	fc.Result = res

	return ec.marshalNMetricChartData2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐMetricChartDataᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetricsCharts_seriesRecall(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetricsCharts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_MetricChartData_x(ctx, field)
			case "y":
				return ec.fieldContext_MetricChartData_y(ctx, field)
			case "z":
				return ec.fieldContext_MetricChartData_z(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MetricChartData", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) _MetricsCharts_seriesSupport(ctx context.Context, field graphql.CollectedField, obj *entity.MetricsCharts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetricsCharts_seriesSupport(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SeriesSupport, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]*entity.MetricChartData)
	fc.Result = res

	return ec.marshalNMetricChartData2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐMetricChartDataᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetricsCharts_seriesSupport(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetricsCharts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_MetricChartData_x(ctx, field)
			case "y":
				return ec.fieldContext_MetricChartData_y(ctx, field)
			case "z":
				return ec.fieldContext_MetricChartData_z(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MetricChartData", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) _MetricsCharts_successVsFails(ctx context.Context, field graphql.CollectedField, obj *entity.MetricsCharts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetricsCharts_successVsFails(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuccessVsFails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]*entity.MetricChartData)
	fc.Result = res

	return ec.marshalNMetricChartData2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐMetricChartDataᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetricsCharts_successVsFails(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetricsCharts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_MetricChartData_x(ctx, field)
			case "y":
				return ec.fieldContext_MetricChartData_y(ctx, field)
			case "z":
				return ec.fieldContext_MetricChartData_z(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MetricChartData", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) _MetricsValues_accuracy(ctx context.Context, field graphql.CollectedField, obj *entity.MetricsValues) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetricsValues_accuracy(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Accuracy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(*entity.MetricsAccuracy)
	fc.Result = res

	return ec.marshalNMetricsAccuracy2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐMetricsAccuracy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetricsValues_accuracy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetricsValues",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_MetricsAccuracy_total(ctx, field)
			case "micro":
				return ec.fieldContext_MetricsAccuracy_micro(ctx, field)
			case "macro":
				return ec.fieldContext_MetricsAccuracy_macro(ctx, field)
			case "weighted":
				return ec.fieldContext_MetricsAccuracy_weighted(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MetricsAccuracy", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) _MetricsValues_missing(ctx context.Context, field graphql.CollectedField, obj *entity.MetricsValues) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetricsValues_missing(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Missing, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(int)
	fc.Result = res

	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetricsValues_missing(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetricsValues",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _MetricsValues_newLabels(ctx context.Context, field graphql.CollectedField, obj *entity.MetricsValues) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetricsValues_newLabels(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewLabels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(int)
	fc.Result = res

	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetricsValues_newLabels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetricsValues",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Mutation_createRuntime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createRuntime(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateRuntime(rctx, fc.Args["input"].(CreateRuntimeInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(*entity.Runtime)
	fc.Result = res

	return ec.marshalNRuntime2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createRuntime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Runtime_id(ctx, field)
			case "name":
				return ec.fieldContext_Runtime_name(ctx, field)
			case "description":
				return ec.fieldContext_Runtime_description(ctx, field)
			case "creationDate":
				return ec.fieldContext_Runtime_creationDate(ctx, field)
			case "measurementsUrl":
				return ec.fieldContext_Runtime_measurementsUrl(ctx, field)
			case "databaseUrl":
				return ec.fieldContext_Runtime_databaseUrl(ctx, field)
			case "entrypointAddress":
				return ec.fieldContext_Runtime_entrypointAddress(ctx, field)
			case "publishedVersion":
				return ec.fieldContext_Runtime_publishedVersion(ctx, field)
			case "creationAuthor":
				return ec.fieldContext_Runtime_creationAuthor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Runtime", field.Name)
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createRuntime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) _Mutation_createVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateVersion(rctx, fc.Args["input"].(CreateVersionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(*entity.Version)
	fc.Result = res

	return ec.marshalNVersion2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "krtVersion":
				return ec.fieldContext_Version_krtVersion(ctx, field)
			case "name":
				return ec.fieldContext_Version_name(ctx, field)
			case "description":
				return ec.fieldContext_Version_description(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "creationDate":
				return ec.fieldContext_Version_creationDate(ctx, field)
			case "creationAuthor":
				return ec.fieldContext_Version_creationAuthor(ctx, field)
			case "publicationDate":
				return ec.fieldContext_Version_publicationDate(ctx, field)
			case "publicationAuthor":
				return ec.fieldContext_Version_publicationAuthor(ctx, field)
			case "workflows":
				return ec.fieldContext_Version_workflows(ctx, field)
			case "config":
				return ec.fieldContext_Version_config(ctx, field)
			case "hasDoc":
				return ec.fieldContext_Version_hasDoc(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) _Mutation_startVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_startVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().StartVersion(rctx, fc.Args["input"].(StartVersionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(*entity.Version)
	fc.Result = res

	return ec.marshalNVersion2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_startVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "krtVersion":
				return ec.fieldContext_Version_krtVersion(ctx, field)
			case "name":
				return ec.fieldContext_Version_name(ctx, field)
			case "description":
				return ec.fieldContext_Version_description(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "creationDate":
				return ec.fieldContext_Version_creationDate(ctx, field)
			case "creationAuthor":
				return ec.fieldContext_Version_creationAuthor(ctx, field)
			case "publicationDate":
				return ec.fieldContext_Version_publicationDate(ctx, field)
			case "publicationAuthor":
				return ec.fieldContext_Version_publicationAuthor(ctx, field)
			case "workflows":
				return ec.fieldContext_Version_workflows(ctx, field)
			case "config":
				return ec.fieldContext_Version_config(ctx, field)
			case "hasDoc":
				return ec.fieldContext_Version_hasDoc(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_startVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) _Mutation_stopVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_stopVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().StopVersion(rctx, fc.Args["input"].(StopVersionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(*entity.Version)
	fc.Result = res

	return ec.marshalNVersion2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_stopVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "krtVersion":
				return ec.fieldContext_Version_krtVersion(ctx, field)
			case "name":
				return ec.fieldContext_Version_name(ctx, field)
			case "description":
				return ec.fieldContext_Version_description(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "creationDate":
				return ec.fieldContext_Version_creationDate(ctx, field)
			case "creationAuthor":
				return ec.fieldContext_Version_creationAuthor(ctx, field)
			case "publicationDate":
				return ec.fieldContext_Version_publicationDate(ctx, field)
			case "publicationAuthor":
				return ec.fieldContext_Version_publicationAuthor(ctx, field)
			case "workflows":
				return ec.fieldContext_Version_workflows(ctx, field)
			case "config":
				return ec.fieldContext_Version_config(ctx, field)
			case "hasDoc":
				return ec.fieldContext_Version_hasDoc(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_stopVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) _Mutation_publishVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_publishVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PublishVersion(rctx, fc.Args["input"].(PublishVersionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(*entity.Version)
	fc.Result = res

	return ec.marshalNVersion2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_publishVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "krtVersion":
				return ec.fieldContext_Version_krtVersion(ctx, field)
			case "name":
				return ec.fieldContext_Version_name(ctx, field)
			case "description":
				return ec.fieldContext_Version_description(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "creationDate":
				return ec.fieldContext_Version_creationDate(ctx, field)
			case "creationAuthor":
				return ec.fieldContext_Version_creationAuthor(ctx, field)
			case "publicationDate":
				return ec.fieldContext_Version_publicationDate(ctx, field)
			case "publicationAuthor":
				return ec.fieldContext_Version_publicationAuthor(ctx, field)
			case "workflows":
				return ec.fieldContext_Version_workflows(ctx, field)
			case "config":
				return ec.fieldContext_Version_config(ctx, field)
			case "hasDoc":
				return ec.fieldContext_Version_hasDoc(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_publishVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) _Mutation_unpublishVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unpublishVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UnpublishVersion(rctx, fc.Args["input"].(UnpublishVersionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(*entity.Version)
	fc.Result = res

	return ec.marshalNVersion2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unpublishVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "krtVersion":
				return ec.fieldContext_Version_krtVersion(ctx, field)
			case "name":
				return ec.fieldContext_Version_name(ctx, field)
			case "description":
				return ec.fieldContext_Version_description(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "creationDate":
				return ec.fieldContext_Version_creationDate(ctx, field)
			case "creationAuthor":
				return ec.fieldContext_Version_creationAuthor(ctx, field)
			case "publicationDate":
				return ec.fieldContext_Version_publicationDate(ctx, field)
			case "publicationAuthor":
				return ec.fieldContext_Version_publicationAuthor(ctx, field)
			case "workflows":
				return ec.fieldContext_Version_workflows(ctx, field)
			case "config":
				return ec.fieldContext_Version_config(ctx, field)
			case "hasDoc":
				return ec.fieldContext_Version_hasDoc(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unpublishVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) _Mutation_updateVersionUserConfiguration(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateVersionUserConfiguration(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateVersionUserConfiguration(rctx, fc.Args["input"].(UpdateConfigurationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(*entity.Version)
	fc.Result = res

	return ec.marshalNVersion2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateVersionUserConfiguration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "krtVersion":
				return ec.fieldContext_Version_krtVersion(ctx, field)
			case "name":
				return ec.fieldContext_Version_name(ctx, field)
			case "description":
				return ec.fieldContext_Version_description(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "creationDate":
				return ec.fieldContext_Version_creationDate(ctx, field)
			case "creationAuthor":
				return ec.fieldContext_Version_creationAuthor(ctx, field)
			case "publicationDate":
				return ec.fieldContext_Version_publicationDate(ctx, field)
			case "publicationAuthor":
				return ec.fieldContext_Version_publicationAuthor(ctx, field)
			case "workflows":
				return ec.fieldContext_Version_workflows(ctx, field)
			case "config":
				return ec.fieldContext_Version_config(ctx, field)
			case "hasDoc":
				return ec.fieldContext_Version_hasDoc(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateVersionUserConfiguration_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) _Mutation_updateAccessLevel(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateAccessLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateAccessLevel(rctx, fc.Args["input"].(UpdateAccessLevelInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]string)
	fc.Result = res

	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateAccessLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateAccessLevel_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) _Node_id(ctx context.Context, field graphql.CollectedField, obj *entity.Node) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Node_id(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Node_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Node_name(ctx context.Context, field graphql.CollectedField, obj *entity.Node) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Node_name(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Node_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Node_status(ctx context.Context, field graphql.CollectedField, obj *entity.Node) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Node_status(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(entity.NodeStatus)
	fc.Result = res

	return ec.marshalNNodeStatus2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐNodeStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Node_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type NodeStatus does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Node_subscriptions(ctx context.Context, field graphql.CollectedField, obj *entity.Node) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Node_subscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subscriptions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.([]string)
	fc.Result = res

	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Node_subscriptions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Node_replicas(ctx context.Context, field graphql.CollectedField, obj *entity.Node) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Node_replicas(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Replicas, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(int32)
	fc.Result = res

	return ec.marshalNInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Node_replicas(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _NodeLog_id(ctx context.Context, field graphql.CollectedField, obj *entity.NodeLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeLog_id(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeLog_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _NodeLog_date(ctx context.Context, field graphql.CollectedField, obj *entity.NodeLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeLog_date(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeLog_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _NodeLog_nodeId(ctx context.Context, field graphql.CollectedField, obj *entity.NodeLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeLog_nodeId(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NodeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeLog_nodeId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _NodeLog_nodeName(ctx context.Context, field graphql.CollectedField, obj *entity.NodeLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeLog_nodeName(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NodeName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeLog_nodeName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _NodeLog_workflowId(ctx context.Context, field graphql.CollectedField, obj *entity.NodeLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeLog_workflowId(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeLog_workflowId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _NodeLog_workflowName(ctx context.Context, field graphql.CollectedField, obj *entity.NodeLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeLog_workflowName(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkflowName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeLog_workflowName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _NodeLog_message(ctx context.Context, field graphql.CollectedField, obj *entity.NodeLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeLog_message(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeLog_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _NodeLog_level(ctx context.Context, field graphql.CollectedField, obj *entity.NodeLog) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeLog_level(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(entity.LogLevel)
	fc.Result = res

	return ec.marshalNLogLevel2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐLogLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeLog_level(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LogLevel does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Query_runtime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_runtime(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Runtime(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(*entity.Runtime)
	fc.Result = res

	return ec.marshalNRuntime2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐRuntime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_runtime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Runtime_id(ctx, field)
			case "name":
				return ec.fieldContext_Runtime_name(ctx, field)
			case "description":
				return ec.fieldContext_Runtime_description(ctx, field)
			case "creationDate":
				return ec.fieldContext_Runtime_creationDate(ctx, field)
			case "measurementsUrl":
				return ec.fieldContext_Runtime_measurementsUrl(ctx, field)
			case "databaseUrl":
				return ec.fieldContext_Runtime_databaseUrl(ctx, field)
			case "entrypointAddress":
				return ec.fieldContext_Runtime_entrypointAddress(ctx, field)
			case "publishedVersion":
				return ec.fieldContext_Runtime_publishedVersion(ctx, field)
			case "creationAuthor":
				return ec.fieldContext_Runtime_creationAuthor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Runtime", field.Name)
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_runtime_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) _Query_runtimes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_runtimes(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Runtimes(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]*entity.Runtime)
	fc.Result = res

	return ec.marshalNRuntime2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐRuntimeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_runtimes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Runtime_id(ctx, field)
			case "name":
				return ec.fieldContext_Runtime_name(ctx, field)
			case "description":
				return ec.fieldContext_Runtime_description(ctx, field)
			case "creationDate":
				return ec.fieldContext_Runtime_creationDate(ctx, field)
			case "measurementsUrl":
				return ec.fieldContext_Runtime_measurementsUrl(ctx, field)
			case "databaseUrl":
				return ec.fieldContext_Runtime_databaseUrl(ctx, field)
			case "entrypointAddress":
				return ec.fieldContext_Runtime_entrypointAddress(ctx, field)
			case "publishedVersion":
				return ec.fieldContext_Runtime_publishedVersion(ctx, field)
			case "creationAuthor":
				return ec.fieldContext_Runtime_creationAuthor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Runtime", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) _Query_version(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_version(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Version(rctx, fc.Args["name"].(string), fc.Args["runtimeId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(*entity.Version)
	fc.Result = res

	return ec.marshalNVersion2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "krtVersion":
				return ec.fieldContext_Version_krtVersion(ctx, field)
			case "name":
				return ec.fieldContext_Version_name(ctx, field)
			case "description":
				return ec.fieldContext_Version_description(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "creationDate":
				return ec.fieldContext_Version_creationDate(ctx, field)
			case "creationAuthor":
				return ec.fieldContext_Version_creationAuthor(ctx, field)
			case "publicationDate":
				return ec.fieldContext_Version_publicationDate(ctx, field)
			case "publicationAuthor":
				return ec.fieldContext_Version_publicationAuthor(ctx, field)
			case "workflows":
				return ec.fieldContext_Version_workflows(ctx, field)
			case "config":
				return ec.fieldContext_Version_config(ctx, field)
			case "hasDoc":
				return ec.fieldContext_Version_hasDoc(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_version_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) _Query_versions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Versions(rctx, fc.Args["runtimeId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]*entity.Version)
	fc.Result = res

	return ec.marshalNVersion2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_versions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "krtVersion":
				return ec.fieldContext_Version_krtVersion(ctx, field)
			case "name":
				return ec.fieldContext_Version_name(ctx, field)
			case "description":
				return ec.fieldContext_Version_description(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "creationDate":
				return ec.fieldContext_Version_creationDate(ctx, field)
			case "creationAuthor":
				return ec.fieldContext_Version_creationAuthor(ctx, field)
			case "publicationDate":
				return ec.fieldContext_Version_publicationDate(ctx, field)
			case "publicationAuthor":
				return ec.fieldContext_Version_publicationAuthor(ctx, field)
			case "workflows":
				return ec.fieldContext_Version_workflows(ctx, field)
			case "config":
				return ec.fieldContext_Version_config(ctx, field)
			case "hasDoc":
				return ec.fieldContext_Version_hasDoc(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_versions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) _Query_userActivityList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userActivityList(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserActivityList(rctx, fc.Args["userEmail"].(*string), fc.Args["types"].([]entity.UserActivityType), fc.Args["versionIds"].([]string), fc.Args["fromDate"].(*string), fc.Args["toDate"].(*string), fc.Args["lastId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]*entity.UserActivity)
	fc.Result = res

	return ec.marshalNUserActivity2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐUserActivityᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userActivityList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserActivity_id(ctx, field)
			case "type":
				return ec.fieldContext_UserActivity_type(ctx, field)
			case "user":
				return ec.fieldContext_UserActivity_user(ctx, field)
			case "date":
				return ec.fieldContext_UserActivity_date(ctx, field)
			case "vars":
				return ec.fieldContext_UserActivity_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserActivity", field.Name)
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userActivityList_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) _Query_logs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_logs(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Logs(rctx, fc.Args["runtimeId"].(string), fc.Args["filters"].(entity.LogFilters), fc.Args["cursor"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(*LogPage)
	fc.Result = res

	return ec.marshalNLogPage2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐLogPage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_logs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_LogPage_cursor(ctx, field)
			case "items":
				return ec.fieldContext_LogPage_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogPage", field.Name)
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_logs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) _Query_metrics(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_metrics(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Metrics(rctx, fc.Args["runtimeId"].(string), fc.Args["versionName"].(string), fc.Args["startDate"].(string), fc.Args["endDate"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*entity.Metrics)
	fc.Result = res

	return ec.marshalOMetrics2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐMetrics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_metrics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "values":
				return ec.fieldContext_Metrics_values(ctx, field)
			case "charts":
				return ec.fieldContext_Metrics_charts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Metrics", field.Name)
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_metrics_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*introspection.Type)
	fc.Result = res

	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*introspection.Schema)
	fc.Result = res

	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) _Runtime_id(ctx context.Context, field graphql.CollectedField, obj *entity.Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_id(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Runtime_name(ctx context.Context, field graphql.CollectedField, obj *entity.Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_name(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Runtime_description(ctx context.Context, field graphql.CollectedField, obj *entity.Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_description(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Runtime_creationDate(ctx context.Context, field graphql.CollectedField, obj *entity.Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_creationDate(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Runtime().CreationDate(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_creationDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Runtime_measurementsUrl(ctx context.Context, field graphql.CollectedField, obj *entity.Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_measurementsUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Runtime().MeasurementsURL(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_measurementsUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Runtime_databaseUrl(ctx context.Context, field graphql.CollectedField, obj *entity.Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_databaseUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Runtime().DatabaseURL(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_databaseUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Runtime_entrypointAddress(ctx context.Context, field graphql.CollectedField, obj *entity.Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_entrypointAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Runtime().EntrypointAddress(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_entrypointAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Runtime_publishedVersion(ctx context.Context, field graphql.CollectedField, obj *entity.Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_publishedVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Runtime().PublishedVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*entity.Version)
	fc.Result = res

	return ec.marshalOVersion2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_publishedVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "krtVersion":
				return ec.fieldContext_Version_krtVersion(ctx, field)
			case "name":
				return ec.fieldContext_Version_name(ctx, field)
			case "description":
				return ec.fieldContext_Version_description(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "creationDate":
				return ec.fieldContext_Version_creationDate(ctx, field)
			case "creationAuthor":
				return ec.fieldContext_Version_creationAuthor(ctx, field)
			case "publicationDate":
				return ec.fieldContext_Version_publicationDate(ctx, field)
			case "publicationAuthor":
				return ec.fieldContext_Version_publicationAuthor(ctx, field)
			case "workflows":
				return ec.fieldContext_Version_workflows(ctx, field)
			case "config":
				return ec.fieldContext_Version_config(ctx, field)
			case "hasDoc":
				return ec.fieldContext_Version_hasDoc(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) _Runtime_creationAuthor(ctx context.Context, field graphql.CollectedField, obj *entity.Runtime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Runtime_creationAuthor(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Runtime().CreationAuthor(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Runtime_creationAuthor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Runtime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Settings_authAllowedDomains(ctx context.Context, field graphql.CollectedField, obj *Settings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Settings_authAllowedDomains(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthAllowedDomains, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]string)
	fc.Result = res

	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Settings_authAllowedDomains(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Settings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Settings_sessionLifetimeInDays(ctx context.Context, field graphql.CollectedField, obj *Settings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Settings_sessionLifetimeInDays(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SessionLifetimeInDays, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(int)
	fc.Result = res

	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Settings_sessionLifetimeInDays(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Settings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Subscription_watchNodeLogs(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_watchNodeLogs(ctx, field)
	if err != nil {
		return nil
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = nil
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().WatchNodeLogs(rctx, fc.Args["runtimeId"].(string), fc.Args["versionName"].(string), fc.Args["filters"].(entity.LogFilters))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return nil
	}

	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *entity.NodeLog):
			if !ok {
				return nil
			}

			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNNodeLog2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐNodeLog(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_watchNodeLogs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_NodeLog_id(ctx, field)
			case "date":
				return ec.fieldContext_NodeLog_date(ctx, field)
			case "nodeId":
				return ec.fieldContext_NodeLog_nodeId(ctx, field)
			case "nodeName":
				return ec.fieldContext_NodeLog_nodeName(ctx, field)
			case "workflowId":
				return ec.fieldContext_NodeLog_workflowId(ctx, field)
			case "workflowName":
				return ec.fieldContext_NodeLog_workflowName(ctx, field)
			case "message":
				return ec.fieldContext_NodeLog_message(ctx, field)
			case "level":
				return ec.fieldContext_NodeLog_level(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeLog", field.Name)
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_watchNodeLogs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) _Subscription_watchNodeStatus(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_watchNodeStatus(ctx, field)
	if err != nil {
		return nil
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = nil
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().WatchNodeStatus(rctx, fc.Args["versionName"].(string), fc.Args["runtimeId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return nil
	}

	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *entity.Node):
			if !ok {
				return nil
			}

			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNNode2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐNode(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_watchNodeStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "name":
				return ec.fieldContext_Node_name(ctx, field)
			case "status":
				return ec.fieldContext_Node_status(ctx, field)
			case "subscriptions":
				return ec.fieldContext_Node_subscriptions(ctx, field)
			case "replicas":
				return ec.fieldContext_Node_replicas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_watchNodeStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) _Subscription_watchVersion(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_watchVersion(ctx, field)
	if err != nil {
		return nil
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = nil
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().WatchVersion(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return nil
	}

	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *entity.Version):
			if !ok {
				return nil
			}

			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNVersion2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersion(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_watchVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "krtVersion":
				return ec.fieldContext_Version_krtVersion(ctx, field)
			case "name":
				return ec.fieldContext_Version_name(ctx, field)
			case "description":
				return ec.fieldContext_Version_description(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "creationDate":
				return ec.fieldContext_Version_creationDate(ctx, field)
			case "creationAuthor":
				return ec.fieldContext_Version_creationAuthor(ctx, field)
			case "publicationDate":
				return ec.fieldContext_Version_publicationDate(ctx, field)
			case "publicationAuthor":
				return ec.fieldContext_Version_publicationAuthor(ctx, field)
			case "workflows":
				return ec.fieldContext_Version_workflows(ctx, field)
			case "config":
				return ec.fieldContext_Version_config(ctx, field)
			case "hasDoc":
				return ec.fieldContext_Version_hasDoc(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) _UserActivity_id(ctx context.Context, field graphql.CollectedField, obj *entity.UserActivity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserActivity_id(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserActivity_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserActivity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _UserActivity_type(ctx context.Context, field graphql.CollectedField, obj *entity.UserActivity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserActivity_type(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(entity.UserActivityType)
	fc.Result = res

	return ec.marshalNUserActivityType2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐUserActivityType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserActivity_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserActivity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserActivityType does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _UserActivity_user(ctx context.Context, field graphql.CollectedField, obj *entity.UserActivity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserActivity_user(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserActivity().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserActivity_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserActivity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _UserActivity_date(ctx context.Context, field graphql.CollectedField, obj *entity.UserActivity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserActivity_date(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserActivity().Date(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserActivity_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserActivity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _UserActivity_vars(ctx context.Context, field graphql.CollectedField, obj *entity.UserActivity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserActivity_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vars, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]*entity.UserActivityVar)
	fc.Result = res

	return ec.marshalNUserActivityVar2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐUserActivityVarᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserActivity_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserActivity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_UserActivityVar_key(ctx, field)
			case "value":
				return ec.fieldContext_UserActivityVar_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserActivityVar", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) _UserActivityVar_key(ctx context.Context, field graphql.CollectedField, obj *entity.UserActivityVar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserActivityVar_key(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserActivityVar_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserActivityVar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _UserActivityVar_value(ctx context.Context, field graphql.CollectedField, obj *entity.UserActivityVar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserActivityVar_value(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserActivityVar_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserActivityVar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Version_id(ctx context.Context, field graphql.CollectedField, obj *entity.Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_id(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Version_krtVersion(ctx context.Context, field graphql.CollectedField, obj *entity.Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_krtVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KrtVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(entity.KrtVersion)
	fc.Result = res

	return ec.marshalNKrtVersion2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐKrtVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_krtVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type KrtVersion does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Version_name(ctx context.Context, field graphql.CollectedField, obj *entity.Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_name(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Version_description(ctx context.Context, field graphql.CollectedField, obj *entity.Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_description(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Version_status(ctx context.Context, field graphql.CollectedField, obj *entity.Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_status(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(entity.VersionStatus)
	fc.Result = res

	return ec.marshalNVersionStatus2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VersionStatus does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Version_creationDate(ctx context.Context, field graphql.CollectedField, obj *entity.Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_creationDate(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().CreationDate(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_creationDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Version_creationAuthor(ctx context.Context, field graphql.CollectedField, obj *entity.Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_creationAuthor(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().CreationAuthor(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_creationAuthor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Version_publicationDate(ctx context.Context, field graphql.CollectedField, obj *entity.Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_publicationDate(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().PublicationDate(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*string)
	fc.Result = res

	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_publicationDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Version_publicationAuthor(ctx context.Context, field graphql.CollectedField, obj *entity.Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_publicationAuthor(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().PublicationAuthor(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*string)
	fc.Result = res

	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_publicationAuthor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Version_workflows(ctx context.Context, field graphql.CollectedField, obj *entity.Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_workflows(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Workflows, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]*entity.Workflow)
	fc.Result = res

	return ec.marshalNWorkflow2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐWorkflowᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_workflows(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Workflow_id(ctx, field)
			case "name":
				return ec.fieldContext_Workflow_name(ctx, field)
			case "entrypoint":
				return ec.fieldContext_Workflow_entrypoint(ctx, field)
			case "exitpoint":
				return ec.fieldContext_Workflow_exitpoint(ctx, field)
			case "nodes":
				return ec.fieldContext_Workflow_nodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Workflow", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) _Version_config(ctx context.Context, field graphql.CollectedField, obj *entity.Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_config(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Config, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(entity.VersionUserConfig)
	fc.Result = res

	return ec.marshalNVersionUserConfig2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersionUserConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "vars":
				return ec.fieldContext_VersionUserConfig_vars(ctx, field)
			case "completed":
				return ec.fieldContext_VersionUserConfig_completed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionUserConfig", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) _Version_hasDoc(ctx context.Context, field graphql.CollectedField, obj *entity.Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_hasDoc(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasDoc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(bool)
	fc.Result = res

	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_hasDoc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Version_errors(ctx context.Context, field graphql.CollectedField, obj *entity.Version) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]string)
	fc.Result = res

	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _VersionUserConfig_vars(ctx context.Context, field graphql.CollectedField, obj *entity.VersionUserConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionUserConfig_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vars, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]*entity.ConfigurationVariable)
	fc.Result = res

	return ec.marshalNConfigurationVariable2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐConfigurationVariableᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionUserConfig_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionUserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_ConfigurationVariable_key(ctx, field)
			case "value":
				return ec.fieldContext_ConfigurationVariable_value(ctx, field)
			case "type":
				return ec.fieldContext_ConfigurationVariable_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfigurationVariable", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) _VersionUserConfig_completed(ctx context.Context, field graphql.CollectedField, obj *entity.VersionUserConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionUserConfig_completed(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Completed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(bool)
	fc.Result = res

	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionUserConfig_completed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionUserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Workflow_id(ctx context.Context, field graphql.CollectedField, obj *entity.Workflow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Workflow_id(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Workflow_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workflow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Workflow_name(ctx context.Context, field graphql.CollectedField, obj *entity.Workflow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Workflow_name(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Workflow_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workflow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Workflow_entrypoint(ctx context.Context, field graphql.CollectedField, obj *entity.Workflow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Workflow_entrypoint(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Entrypoint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Workflow_entrypoint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workflow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Workflow_exitpoint(ctx context.Context, field graphql.CollectedField, obj *entity.Workflow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Workflow_exitpoint(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exitpoint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Workflow_exitpoint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workflow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) _Workflow_nodes(ctx context.Context, field graphql.CollectedField, obj *entity.Workflow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Workflow_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]entity.Node)
	fc.Result = res

	return ec.marshalNNode2ᚕgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐNodeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Workflow_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Workflow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "name":
				return ec.fieldContext_Node_name(ctx, field)
			case "status":
				return ec.fieldContext_Node_status(ctx, field)
			case "subscriptions":
				return ec.fieldContext_Node_subscriptions(ctx, field)
			case "replicas":
				return ec.fieldContext_Node_replicas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*string)
	fc.Result = res

	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]string)
	fc.Result = res

	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]introspection.InputValue)
	fc.Result = res

	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(bool)
	fc.Result = res

	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*string)
	fc.Result = res

	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(bool)
	fc.Result = res

	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*string)
	fc.Result = res

	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*string)
	fc.Result = res

	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]introspection.InputValue)
	fc.Result = res

	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(*introspection.Type)
	fc.Result = res

	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(bool)
	fc.Result = res

	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*string)
	fc.Result = res

	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*string)
	fc.Result = res

	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(*introspection.Type)
	fc.Result = res

	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*string)
	fc.Result = res

	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*string)
	fc.Result = res

	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]introspection.Type)
	fc.Result = res

	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(*introspection.Type)
	fc.Result = res

	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*introspection.Type)
	fc.Result = res

	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*introspection.Type)
	fc.Result = res

	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.([]introspection.Directive)
	fc.Result = res

	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}

		return graphql.Null
	}

	res := resTmp.(string)
	fc.Result = res

	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*string)
	fc.Result = res

	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*string)
	fc.Result = res

	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.([]introspection.Field)
	fc.Result = res

	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.([]introspection.Type)
	fc.Result = res

	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.([]introspection.Type)
	fc.Result = res

	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.([]introspection.EnumValue)
	fc.Result = res

	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}

	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}

	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.([]introspection.InputValue)
	fc.Result = res

	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*introspection.Type)
	fc.Result = res

	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}

	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}

	ctx = graphql.WithFieldContext(ctx, fc)

	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))

			ret = graphql.Null
		}
	}()

	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}

	if resTmp == nil {
		return graphql.Null
	}

	res := resTmp.(*string)
	fc.Result = res

	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}

	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputConfigurationVariablesInput(ctx context.Context, obj interface{}) (ConfigurationVariablesInput, error) {
	var it ConfigurationVariablesInput

	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}

		switch k {
		case "key":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))

			it.Key, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))

			it.Value, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateRuntimeInput(ctx context.Context, obj interface{}) (CreateRuntimeInput, error) {
	var it CreateRuntimeInput

	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}

		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))

			it.ID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))

			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))

			it.Description, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateVersionInput(ctx context.Context, obj interface{}) (CreateVersionInput, error) {
	var it CreateVersionInput

	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"file", "runtimeId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}

		switch k {
		case "file":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("file"))

			it.File, err = ec.unmarshalNUpload2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx, v)
			if err != nil {
				return it, err
			}
		case "runtimeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeId"))

			it.RuntimeID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLogFilters(ctx context.Context, obj interface{}) (entity.LogFilters, error) {
	var it entity.LogFilters

	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"startDate", "endDate", "search", "levels", "nodeIds", "versionsIds", "workflowsNames"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}

		switch k {
		case "startDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))

			it.StartDate, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDate"))

			it.EndDate, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "search":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))

			it.Search, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "levels":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levels"))

			it.Levels, err = ec.unmarshalOLogLevel2ᚕgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐLogLevelᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nodeIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nodeIds"))

			it.NodeIDs, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "versionsIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionsIds"))

			it.VersionsIDs, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "workflowsNames":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workflowsNames"))

			it.WorkflowsNames, err = ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPublishVersionInput(ctx context.Context, obj interface{}) (PublishVersionInput, error) {
	var it PublishVersionInput

	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"versionName", "comment", "runtimeId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}

		switch k {
		case "versionName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionName"))

			it.VersionName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "comment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))

			it.Comment, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "runtimeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeId"))

			it.RuntimeID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSettingsInput(ctx context.Context, obj interface{}) (SettingsInput, error) {
	var it SettingsInput

	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"authAllowedDomains", "sessionLifetimeInDays"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}

		switch k {
		case "authAllowedDomains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authAllowedDomains"))

			it.AuthAllowedDomains, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "sessionLifetimeInDays":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sessionLifetimeInDays"))

			it.SessionLifetimeInDays, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStartVersionInput(ctx context.Context, obj interface{}) (StartVersionInput, error) {
	var it StartVersionInput

	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"versionName", "comment", "runtimeId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}

		switch k {
		case "versionName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionName"))

			it.VersionName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "comment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))

			it.Comment, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "runtimeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeId"))

			it.RuntimeID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStopVersionInput(ctx context.Context, obj interface{}) (StopVersionInput, error) {
	var it StopVersionInput

	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"versionName", "comment", "runtimeId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}

		switch k {
		case "versionName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionName"))

			it.VersionName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "comment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))

			it.Comment, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "runtimeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeId"))

			it.RuntimeID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUnpublishVersionInput(ctx context.Context, obj interface{}) (UnpublishVersionInput, error) {
	var it UnpublishVersionInput

	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"versionName", "comment", "runtimeId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}

		switch k {
		case "versionName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionName"))

			it.VersionName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "comment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))

			it.Comment, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "runtimeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeId"))

			it.RuntimeID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateAccessLevelInput(ctx context.Context, obj interface{}) (UpdateAccessLevelInput, error) {
	var it UpdateAccessLevelInput

	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userIds", "accessLevel", "comment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}

		switch k {
		case "userIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIds"))

			it.UserIds, err = ec.unmarshalNID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessLevel":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessLevel"))

			it.AccessLevel, err = ec.unmarshalNAccessLevel2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐAccessLevel(ctx, v)
			if err != nil {
				return it, err
			}
		case "comment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))

			it.Comment, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateConfigurationInput(ctx context.Context, obj interface{}) (UpdateConfigurationInput, error) {
	var it UpdateConfigurationInput

	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"versionName", "runtimeId", "configurationVariables"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}

		switch k {
		case "versionName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionName"))

			it.VersionName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "runtimeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeId"))

			it.RuntimeID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "configurationVariables":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configurationVariables"))

			it.ConfigurationVariables, err = ec.unmarshalNConfigurationVariablesInput2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐConfigurationVariablesInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUsersInput(ctx context.Context, obj interface{}) (UsersInput, error) {
	var it UsersInput

	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"userIds", "comment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}

		switch k {
		case "userIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIds"))

			it.UserIds, err = ec.unmarshalNID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "comment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))

			it.Comment, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var apiTokenImplementors = []string{"ApiToken"}

func (ec *executionContext) _ApiToken(ctx context.Context, sel ast.SelectionSet, obj *entity.APIToken) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, apiTokenImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApiToken")
		case "id":
			out.Values[i] = ec._ApiToken_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._ApiToken_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "creationDate":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._ApiToken_creationDate(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}

				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)
			})
		case "lastActivity":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._ApiToken_lastActivity(ctx, field, obj)

				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var configurationVariableImplementors = []string{"ConfigurationVariable"}

func (ec *executionContext) _ConfigurationVariable(ctx context.Context, sel ast.SelectionSet, obj *entity.ConfigurationVariable) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, configurationVariableImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigurationVariable")
		case "key":
			out.Values[i] = ec._ConfigurationVariable_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":
			out.Values[i] = ec._ConfigurationVariable_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec._ConfigurationVariable_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var logPageImplementors = []string{"LogPage"}

func (ec *executionContext) _LogPage(ctx context.Context, sel ast.SelectionSet, obj *LogPage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logPageImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogPage")
		case "cursor":
			out.Values[i] = ec._LogPage_cursor(ctx, field, obj)

		case "items":
			out.Values[i] = ec._LogPage_items(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var metricChartDataImplementors = []string{"MetricChartData"}

func (ec *executionContext) _MetricChartData(ctx context.Context, sel ast.SelectionSet, obj *entity.MetricChartData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metricChartDataImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MetricChartData")
		case "x":
			out.Values[i] = ec._MetricChartData_x(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "y":
			out.Values[i] = ec._MetricChartData_y(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "z":
			out.Values[i] = ec._MetricChartData_z(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var metricsImplementors = []string{"Metrics"}

func (ec *executionContext) _Metrics(ctx context.Context, sel ast.SelectionSet, obj *entity.Metrics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metricsImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Metrics")
		case "values":
			out.Values[i] = ec._Metrics_values(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "charts":
			out.Values[i] = ec._Metrics_charts(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var metricsAccuracyImplementors = []string{"MetricsAccuracy"}

func (ec *executionContext) _MetricsAccuracy(ctx context.Context, sel ast.SelectionSet, obj *entity.MetricsAccuracy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metricsAccuracyImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MetricsAccuracy")
		case "total":
			out.Values[i] = ec._MetricsAccuracy_total(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "micro":
			out.Values[i] = ec._MetricsAccuracy_micro(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "macro":
			out.Values[i] = ec._MetricsAccuracy_macro(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "weighted":
			out.Values[i] = ec._MetricsAccuracy_weighted(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var metricsChartsImplementors = []string{"MetricsCharts"}

func (ec *executionContext) _MetricsCharts(ctx context.Context, sel ast.SelectionSet, obj *entity.MetricsCharts) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metricsChartsImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MetricsCharts")
		case "confusionMatrix":
			out.Values[i] = ec._MetricsCharts_confusionMatrix(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "seriesAccuracy":
			out.Values[i] = ec._MetricsCharts_seriesAccuracy(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "seriesRecall":
			out.Values[i] = ec._MetricsCharts_seriesRecall(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "seriesSupport":
			out.Values[i] = ec._MetricsCharts_seriesSupport(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "successVsFails":
			out.Values[i] = ec._MetricsCharts_successVsFails(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var metricsValuesImplementors = []string{"MetricsValues"}

func (ec *executionContext) _MetricsValues(ctx context.Context, sel ast.SelectionSet, obj *entity.MetricsValues) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metricsValuesImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MetricsValues")
		case "accuracy":
			out.Values[i] = ec._MetricsValues_accuracy(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "missing":
			out.Values[i] = ec._MetricsValues_missing(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "newLabels":
			out.Values[i] = ec._MetricsValues_newLabels(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createRuntime":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createRuntime(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createVersion(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_startVersion(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "stopVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_stopVersion(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "publishVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_publishVersion(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "unpublishVersion":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unpublishVersion(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateVersionUserConfiguration":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateVersionUserConfiguration(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateAccessLevel":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateAccessLevel(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var nodeImplementors = []string{"Node"}

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj *entity.Node) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nodeImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Node")
		case "id":
			out.Values[i] = ec._Node_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._Node_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "status":
			out.Values[i] = ec._Node_status(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "subscriptions":
			out.Values[i] = ec._Node_subscriptions(ctx, field, obj)

		case "replicas":
			out.Values[i] = ec._Node_replicas(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var nodeLogImplementors = []string{"NodeLog"}

func (ec *executionContext) _NodeLog(ctx context.Context, sel ast.SelectionSet, obj *entity.NodeLog) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nodeLogImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NodeLog")
		case "id":
			out.Values[i] = ec._NodeLog_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "date":
			out.Values[i] = ec._NodeLog_date(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "nodeId":
			out.Values[i] = ec._NodeLog_nodeId(ctx, field, obj)

		case "nodeName":
			out.Values[i] = ec._NodeLog_nodeName(ctx, field, obj)

		case "workflowId":
			out.Values[i] = ec._NodeLog_workflowId(ctx, field, obj)

		case "workflowName":
			out.Values[i] = ec._NodeLog_workflowName(ctx, field, obj)

		case "message":
			out.Values[i] = ec._NodeLog_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "level":
			out.Values[i] = ec._NodeLog_level(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "runtime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._Query_runtime(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}

				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "runtimes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._Query_runtimes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}

				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "version":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._Query_version(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}

				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "versions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._Query_versions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}

				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "userActivityList":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._Query_userActivityList(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}

				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "logs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._Query_logs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}

				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "metrics":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._Query_metrics(ctx, field)

				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var runtimeImplementors = []string{"Runtime"}

func (ec *executionContext) _Runtime(ctx context.Context, sel ast.SelectionSet, obj *entity.Runtime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Runtime")
		case "id":
			out.Values[i] = ec._Runtime_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Runtime_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Runtime_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "creationDate":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._Runtime_creationDate(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}

				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)
			})
		case "measurementsUrl":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._Runtime_measurementsUrl(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}

				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)
			})
		case "databaseUrl":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._Runtime_databaseUrl(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}

				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)
			})
		case "entrypointAddress":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._Runtime_entrypointAddress(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}

				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)
			})
		case "publishedVersion":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._Runtime_publishedVersion(ctx, field, obj)

				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)
			})
		case "creationAuthor":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._Runtime_creationAuthor(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}

				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var settingsImplementors = []string{"Settings"}

func (ec *executionContext) _Settings(ctx context.Context, sel ast.SelectionSet, obj *Settings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, settingsImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Settings")
		case "authAllowedDomains":
			out.Values[i] = ec._Settings_authAllowedDomains(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sessionLifetimeInDays":
			out.Values[i] = ec._Settings_sessionLifetimeInDays(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})

	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "watchNodeLogs":
		return ec._Subscription_watchNodeLogs(ctx, fields[0])
	case "watchNodeStatus":
		return ec._Subscription_watchNodeStatus(ctx, fields[0])
	case "watchVersion":
		return ec._Subscription_watchVersion(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var userActivityImplementors = []string{"UserActivity"}

func (ec *executionContext) _UserActivity(ctx context.Context, sel ast.SelectionSet, obj *entity.UserActivity) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userActivityImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserActivity")
		case "id":
			out.Values[i] = ec._UserActivity_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			out.Values[i] = ec._UserActivity_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._UserActivity_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}

				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)
			})
		case "date":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._UserActivity_date(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}

				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)
			})
		case "vars":
			out.Values[i] = ec._UserActivity_vars(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var userActivityVarImplementors = []string{"UserActivityVar"}

func (ec *executionContext) _UserActivityVar(ctx context.Context, sel ast.SelectionSet, obj *entity.UserActivityVar) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userActivityVarImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserActivityVar")
		case "key":
			out.Values[i] = ec._UserActivityVar_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":
			out.Values[i] = ec._UserActivityVar_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var versionImplementors = []string{"Version"}

func (ec *executionContext) _Version(ctx context.Context, sel ast.SelectionSet, obj *entity.Version) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Version")
		case "id":
			out.Values[i] = ec._Version_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "krtVersion":
			out.Values[i] = ec._Version_krtVersion(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Version_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Version_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "status":
			out.Values[i] = ec._Version_status(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "creationDate":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._Version_creationDate(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}

				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)
			})
		case "creationAuthor":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._Version_creationAuthor(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}

				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)
			})
		case "publicationDate":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._Version_publicationDate(ctx, field, obj)

				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)
			})
		case "publicationAuthor":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()

				res = ec._Version_publicationAuthor(ctx, field, obj)

				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)
			})
		case "workflows":
			out.Values[i] = ec._Version_workflows(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "config":
			out.Values[i] = ec._Version_config(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "hasDoc":
			out.Values[i] = ec._Version_hasDoc(ctx, field, obj)

		case "errors":
			out.Values[i] = ec._Version_errors(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var versionUserConfigImplementors = []string{"VersionUserConfig"}

func (ec *executionContext) _VersionUserConfig(ctx context.Context, sel ast.SelectionSet, obj *entity.VersionUserConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionUserConfigImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionUserConfig")
		case "vars":
			out.Values[i] = ec._VersionUserConfig_vars(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "completed":
			out.Values[i] = ec._VersionUserConfig_completed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var workflowImplementors = []string{"Workflow"}

func (ec *executionContext) _Workflow(ctx context.Context, sel ast.SelectionSet, obj *entity.Workflow) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workflowImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Workflow")
		case "id":
			out.Values[i] = ec._Workflow_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._Workflow_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "entrypoint":
			out.Values[i] = ec._Workflow_entrypoint(ctx, field, obj)

		case "exitpoint":
			out.Values[i] = ec._Workflow_exitpoint(ctx, field, obj)

		case "nodes":
			out.Values[i] = ec._Workflow_nodes(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)

	var invalids uint32

	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	out.Dispatch()

	if invalids > 0 {
		return graphql.Null
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAccessLevel2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐAccessLevel(ctx context.Context, v interface{}) (AccessLevel, error) {
	var res AccessLevel
	err := res.UnmarshalGQL(v)

	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAccessLevel2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐAccessLevel(ctx context.Context, sel ast.SelectionSet, v AccessLevel) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}

	return res
}

func (ec *executionContext) marshalNConfigurationVariable2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐConfigurationVariableᚄ(ctx context.Context, sel ast.SelectionSet, v []*entity.ConfigurationVariable) graphql.Marshaler {
	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalNConfigurationVariable2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐConfigurationVariable(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNConfigurationVariable2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐConfigurationVariable(ctx context.Context, sel ast.SelectionSet, v *entity.ConfigurationVariable) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}

		return graphql.Null
	}

	return ec._ConfigurationVariable(ctx, sel, v)
}

func (ec *executionContext) unmarshalNConfigurationVariableType2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐConfigurationVariableType(ctx context.Context, v interface{}) (entity.ConfigurationVariableType, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := entity.ConfigurationVariableType(tmp)

	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConfigurationVariableType2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐConfigurationVariableType(ctx context.Context, sel ast.SelectionSet, v entity.ConfigurationVariableType) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}

	return res
}

func (ec *executionContext) unmarshalNConfigurationVariablesInput2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐConfigurationVariablesInputᚄ(ctx context.Context, v interface{}) ([]*ConfigurationVariablesInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}

	var err error

	res := make([]*ConfigurationVariablesInput, len(vSlice))

	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))

		res[i], err = ec.unmarshalNConfigurationVariablesInput2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐConfigurationVariablesInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}

	return res, nil
}

func (ec *executionContext) unmarshalNConfigurationVariablesInput2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐConfigurationVariablesInput(ctx context.Context, v interface{}) (*ConfigurationVariablesInput, error) {
	res, err := ec.unmarshalInputConfigurationVariablesInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateRuntimeInput2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐCreateRuntimeInput(ctx context.Context, v interface{}) (CreateRuntimeInput, error) {
	res, err := ec.unmarshalInputCreateRuntimeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateVersionInput2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐCreateVersionInput(ctx context.Context, v interface{}) (CreateVersionInput, error) {
	res, err := ec.unmarshalInputCreateVersionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}

	return res
}

func (ec *executionContext) unmarshalNID2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}

	var err error

	res := make([]string, len(vSlice))

	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))

		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}

	return res, nil
}

func (ec *executionContext) marshalNID2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}

	return res
}

func (ec *executionContext) unmarshalNInt2int32(ctx context.Context, v interface{}) (int32, error) {
	res, err := graphql.UnmarshalInt32(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int32(ctx context.Context, sel ast.SelectionSet, v int32) graphql.Marshaler {
	res := graphql.MarshalInt32(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}

	return res
}

func (ec *executionContext) unmarshalNKrtVersion2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐKrtVersion(ctx context.Context, v interface{}) (entity.KrtVersion, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := entity.KrtVersion(tmp)

	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNKrtVersion2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐKrtVersion(ctx context.Context, sel ast.SelectionSet, v entity.KrtVersion) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}

	return res
}

func (ec *executionContext) unmarshalNLogFilters2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐLogFilters(ctx context.Context, v interface{}) (entity.LogFilters, error) {
	res, err := ec.unmarshalInputLogFilters(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNLogLevel2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐLogLevel(ctx context.Context, v interface{}) (entity.LogLevel, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := entity.LogLevel(tmp)

	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLogLevel2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐLogLevel(ctx context.Context, sel ast.SelectionSet, v entity.LogLevel) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}

	return res
}

func (ec *executionContext) marshalNLogPage2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐLogPage(ctx context.Context, sel ast.SelectionSet, v LogPage) graphql.Marshaler {
	return ec._LogPage(ctx, sel, &v)
}

func (ec *executionContext) marshalNLogPage2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐLogPage(ctx context.Context, sel ast.SelectionSet, v *LogPage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}

		return graphql.Null
	}

	return ec._LogPage(ctx, sel, v)
}

func (ec *executionContext) marshalNMetricChartData2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐMetricChartDataᚄ(ctx context.Context, sel ast.SelectionSet, v []*entity.MetricChartData) graphql.Marshaler {
	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalNMetricChartData2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐMetricChartData(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMetricChartData2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐMetricChartData(ctx context.Context, sel ast.SelectionSet, v *entity.MetricChartData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}

		return graphql.Null
	}

	return ec._MetricChartData(ctx, sel, v)
}

func (ec *executionContext) marshalNMetricsAccuracy2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐMetricsAccuracy(ctx context.Context, sel ast.SelectionSet, v *entity.MetricsAccuracy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}

		return graphql.Null
	}

	return ec._MetricsAccuracy(ctx, sel, v)
}

func (ec *executionContext) marshalNMetricsCharts2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐMetricsCharts(ctx context.Context, sel ast.SelectionSet, v *entity.MetricsCharts) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}

		return graphql.Null
	}

	return ec._MetricsCharts(ctx, sel, v)
}

func (ec *executionContext) marshalNMetricsValues2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐMetricsValues(ctx context.Context, sel ast.SelectionSet, v *entity.MetricsValues) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}

		return graphql.Null
	}

	return ec._MetricsValues(ctx, sel, v)
}

func (ec *executionContext) marshalNNode2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐNode(ctx context.Context, sel ast.SelectionSet, v entity.Node) graphql.Marshaler {
	return ec._Node(ctx, sel, &v)
}

func (ec *executionContext) marshalNNode2ᚕgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐNodeᚄ(ctx context.Context, sel ast.SelectionSet, v []entity.Node) graphql.Marshaler {
	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalNNode2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐNode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNNode2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐNode(ctx context.Context, sel ast.SelectionSet, v *entity.Node) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}

		return graphql.Null
	}

	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalNNodeLog2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐNodeLog(ctx context.Context, sel ast.SelectionSet, v entity.NodeLog) graphql.Marshaler {
	return ec._NodeLog(ctx, sel, &v)
}

func (ec *executionContext) marshalNNodeLog2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐNodeLogᚄ(ctx context.Context, sel ast.SelectionSet, v []*entity.NodeLog) graphql.Marshaler {
	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalNNodeLog2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐNodeLog(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNNodeLog2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐNodeLog(ctx context.Context, sel ast.SelectionSet, v *entity.NodeLog) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}

		return graphql.Null
	}

	return ec._NodeLog(ctx, sel, v)
}

func (ec *executionContext) unmarshalNNodeStatus2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐNodeStatus(ctx context.Context, v interface{}) (entity.NodeStatus, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := entity.NodeStatus(tmp)

	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNodeStatus2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐNodeStatus(ctx context.Context, sel ast.SelectionSet, v entity.NodeStatus) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}

	return res
}

func (ec *executionContext) unmarshalNPublishVersionInput2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐPublishVersionInput(ctx context.Context, v interface{}) (PublishVersionInput, error) {
	res, err := ec.unmarshalInputPublishVersionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRuntime2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐRuntime(ctx context.Context, sel ast.SelectionSet, v entity.Runtime) graphql.Marshaler {
	return ec._Runtime(ctx, sel, &v)
}

func (ec *executionContext) marshalNRuntime2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐRuntimeᚄ(ctx context.Context, sel ast.SelectionSet, v []*entity.Runtime) graphql.Marshaler {
	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalNRuntime2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐRuntime(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRuntime2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐRuntime(ctx context.Context, sel ast.SelectionSet, v *entity.Runtime) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}

		return graphql.Null
	}

	return ec._Runtime(ctx, sel, v)
}

func (ec *executionContext) unmarshalNStartVersionInput2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐStartVersionInput(ctx context.Context, v interface{}) (StartVersionInput, error) {
	res, err := ec.unmarshalInputStartVersionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNStopVersionInput2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐStopVersionInput(ctx context.Context, v interface{}) (StopVersionInput, error) {
	res, err := ec.unmarshalInputStopVersionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}

	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}

	var err error

	res := make([]string, len(vSlice))

	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))

		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}

	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNUnpublishVersionInput2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐUnpublishVersionInput(ctx context.Context, v interface{}) (UnpublishVersionInput, error) {
	res, err := ec.unmarshalInputUnpublishVersionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateAccessLevelInput2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐUpdateAccessLevelInput(ctx context.Context, v interface{}) (UpdateAccessLevelInput, error) {
	res, err := ec.unmarshalInputUpdateAccessLevelInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateConfigurationInput2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋadapterᚋgqlᚐUpdateConfigurationInput(ctx context.Context, v interface{}) (UpdateConfigurationInput, error) {
	res, err := ec.unmarshalInputUpdateConfigurationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpload2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx context.Context, v interface{}) (graphql.Upload, error) {
	res, err := graphql.UnmarshalUpload(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpload2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚐUpload(ctx context.Context, sel ast.SelectionSet, v graphql.Upload) graphql.Marshaler {
	res := graphql.MarshalUpload(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}

	return res
}

func (ec *executionContext) marshalNUserActivity2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐUserActivityᚄ(ctx context.Context, sel ast.SelectionSet, v []*entity.UserActivity) graphql.Marshaler {
	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalNUserActivity2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐUserActivity(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserActivity2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐUserActivity(ctx context.Context, sel ast.SelectionSet, v *entity.UserActivity) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}

		return graphql.Null
	}

	return ec._UserActivity(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserActivityType2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐUserActivityType(ctx context.Context, v interface{}) (entity.UserActivityType, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := entity.UserActivityType(tmp)

	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserActivityType2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐUserActivityType(ctx context.Context, sel ast.SelectionSet, v entity.UserActivityType) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}

	return res
}

func (ec *executionContext) marshalNUserActivityVar2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐUserActivityVarᚄ(ctx context.Context, sel ast.SelectionSet, v []*entity.UserActivityVar) graphql.Marshaler {
	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalNUserActivityVar2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐUserActivityVar(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserActivityVar2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐUserActivityVar(ctx context.Context, sel ast.SelectionSet, v *entity.UserActivityVar) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}

		return graphql.Null
	}

	return ec._UserActivityVar(ctx, sel, v)
}

func (ec *executionContext) marshalNVersion2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersion(ctx context.Context, sel ast.SelectionSet, v entity.Version) graphql.Marshaler {
	return ec._Version(ctx, sel, &v)
}

func (ec *executionContext) marshalNVersion2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersionᚄ(ctx context.Context, sel ast.SelectionSet, v []*entity.Version) graphql.Marshaler {
	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalNVersion2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNVersion2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersion(ctx context.Context, sel ast.SelectionSet, v *entity.Version) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}

		return graphql.Null
	}

	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVersionStatus2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersionStatus(ctx context.Context, v interface{}) (entity.VersionStatus, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := entity.VersionStatus(tmp)

	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVersionStatus2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersionStatus(ctx context.Context, sel ast.SelectionSet, v entity.VersionStatus) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}

	return res
}

func (ec *executionContext) marshalNVersionUserConfig2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersionUserConfig(ctx context.Context, sel ast.SelectionSet, v entity.VersionUserConfig) graphql.Marshaler {
	return ec._VersionUserConfig(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkflow2ᚕᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐWorkflowᚄ(ctx context.Context, sel ast.SelectionSet, v []*entity.Workflow) graphql.Marshaler {
	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalNWorkflow2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐWorkflow(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWorkflow2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐWorkflow(ctx context.Context, sel ast.SelectionSet, v *entity.Workflow) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}

		return graphql.Null
	}

	return ec._Workflow(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}

	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}

	var err error

	res := make([]string, len(vSlice))

	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))

		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}

	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}

		return graphql.Null
	}

	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}

	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}

	res, err := graphql.UnmarshalBoolean(v)

	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}

	res := graphql.MarshalBoolean(*v)

	return res
}

func (ec *executionContext) unmarshalOID2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}

	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}

	var err error

	res := make([]string, len(vSlice))

	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))

		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}

	return res, nil
}

func (ec *executionContext) marshalOID2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}

	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}

	res, err := graphql.UnmarshalInt(v)

	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}

	res := graphql.MarshalInt(*v)

	return res
}

func (ec *executionContext) unmarshalOLogLevel2ᚕgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐLogLevelᚄ(ctx context.Context, v interface{}) ([]entity.LogLevel, error) {
	if v == nil {
		return nil, nil
	}

	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}

	var err error

	res := make([]entity.LogLevel, len(vSlice))

	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))

		res[i], err = ec.unmarshalNLogLevel2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐLogLevel(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}

	return res, nil
}

func (ec *executionContext) marshalOLogLevel2ᚕgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐLogLevelᚄ(ctx context.Context, sel ast.SelectionSet, v []entity.LogLevel) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}

	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalNLogLevel2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐLogLevel(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOMetrics2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐMetrics(ctx context.Context, sel ast.SelectionSet, v *entity.Metrics) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}

	return ec._Metrics(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}

	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}

	var err error

	res := make([]string, len(vSlice))

	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))

		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}

	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}

	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}

	res, err := graphql.UnmarshalString(v)

	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}

	res := graphql.MarshalString(*v)

	return res
}

func (ec *executionContext) unmarshalOUserActivityType2ᚕgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐUserActivityTypeᚄ(ctx context.Context, v interface{}) ([]entity.UserActivityType, error) {
	if v == nil {
		return nil, nil
	}

	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}

	var err error

	res := make([]entity.UserActivityType, len(vSlice))

	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))

		res[i], err = ec.unmarshalNUserActivityType2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐUserActivityType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}

	return res, nil
}

func (ec *executionContext) marshalOUserActivityType2ᚕgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐUserActivityTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []entity.UserActivityType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}

	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalNUserActivityType2githubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐUserActivityType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOVersion2ᚖgithubᚗcomᚋkonstellationᚑioᚋkreᚋengineᚋadminᚑapiᚋdomainᚋentityᚐVersion(ctx context.Context, sel ast.SelectionSet, v *entity.Version) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}

	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}

	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}

	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}

	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}

	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}

	ret := make(graphql.Array, len(v))

	var wg sync.WaitGroup

	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}

	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)

		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))

					ret = nil
				}
			}()

			if !isLen1 {
				defer wg.Done()
			}

			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}
	}

	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
